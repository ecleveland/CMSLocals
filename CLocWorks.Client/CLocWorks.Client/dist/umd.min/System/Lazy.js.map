{"version":3,"sources":["System/Lazy.js","System/Lazy.ts"],"names":["__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","factory","module","exports","v","require","undefined","define","amd","ResolverBase_1","Lazy","_super","valueFactory","trapExceptions","allowReset","call","_disposableObjectName","_isValueCreated","defineProperty","get","enumerable","configurable","getValue","equals","other","valueEquals","value","ResolverBase"],"mappings":";;;;AAIA,GAAIA,WAAaC,MAAQA,KAAKD,WAAc,SAAUE,EAAGC,GAErD,QAASC,KAAOH,KAAKI,YAAcH,EADnC,IAAK,GAAII,KAAKH,GAAOA,EAAEI,eAAeD,KAAIJ,EAAEI,GAAKH,EAAEG,GAEnDJ,GAAEM,UAAkB,OAANL,EAAaM,OAAOC,OAAOP,IAAMC,EAAGI,UAAYL,EAAEK,UAAW,GAAIJ,MAEnF,SAAWO,GACP,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QAAoBG,UAANF,IAAiBF,OAAOC,QAAUC,OAElD,kBAAXG,SAAyBA,OAAOC,KAC5CD,QAAQ,UAAW,UAAW,kBAAmBN,IAEtD,SAAUI,EAASF,GAClB,YCVJ,IAAAM,GAAAJ,EAA2B,kBAG3BK,EAAA,SAAAC,GAGC,QAAAD,GAAYE,EAAsBC,EAAgCC,GAAhC,SAAAD,IAAAA,GAAA,GAAgC,SAAAC,IAAAA,GAAA,GAEjEH,EAAAI,KAAAxB,KAAMqB,EAAcC,EAAgBC,GACpCvB,KAAKyB,sBAAwB,OAC7BzB,KAAK0B,iBAAkB,EAuBzB,MA9B6B3B,WAAAoB,EAAAC,GAU5BZ,OAAAmB,eAAIR,EAAAZ,UAAA,kBDSOqB,ICTX,WAEC,QAAS5B,KAAK0B,iBDUJG,YAAY,EACZC,cAAc,ICRzBtB,OAAAmB,eAAIR,EAAAZ,UAAA,SDWOqB,ICXX,WAEC,MAAO5B,MAAK+B,YDYFF,YAAY,EACZC,cAAc,ICVzBX,EAAAZ,UAAAyB,OAAA,SAAOC,GAEN,MAAOjC,OAAMiC,GAGdd,EAAAZ,UAAA2B,YAAA,SAAYD,GAEX,MAAOjC,MAAKgC,OAAOC,IAAUjC,KAAKmC,QAAQF,EAAME,OAGlDhB,GA9B6BD,EAAAkB,aAAhBxB,GAAAO,KAAIA,EAgCjBX,OAAAmB,eAAAf,EAAA,cAAAuB,OAAA,IDUIvB,EAAAA,WCVWO","file":"System/Lazy.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", \"./ResolverBase\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var ResolverBase_1 = require(\"./ResolverBase\");\n    var Lazy = (function (_super) {\n        __extends(Lazy, _super);\n        function Lazy(valueFactory, trapExceptions, allowReset) {\n            if (trapExceptions === void 0) { trapExceptions = false; }\n            if (allowReset === void 0) { allowReset = false; }\n            _super.call(this, valueFactory, trapExceptions, allowReset);\n            this._disposableObjectName = 'Lazy';\n            this._isValueCreated = false;\n        }\n        Object.defineProperty(Lazy.prototype, \"isValueCreated\", {\n            get: function () {\n                return !!this._isValueCreated;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Lazy.prototype, \"value\", {\n            get: function () {\n                return this.getValue();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Lazy.prototype.equals = function (other) {\n            return this == other;\n        };\n        Lazy.prototype.valueEquals = function (other) {\n            return this.equals(other) || this.value === other.value;\n        };\n        return Lazy;\n    }(ResolverBase_1.ResolverBase));\n    exports.Lazy = Lazy;\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = Lazy;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {ILazy} from \"./ILazy\";\r\nimport {Func} from \"./FunctionTypes\";\r\nimport {ResolverBase} from \"./ResolverBase\";\r\n\r\n// We need a non-resettable lazy to ensure it can be passed safely around.\r\nexport class Lazy<T> extends ResolverBase<T> implements ILazy<T>\r\n{\r\n\r\n\tconstructor(valueFactory:Func<T>, trapExceptions:boolean = false, allowReset:boolean = false)\r\n\t{\r\n\t\tsuper(valueFactory, trapExceptions, allowReset);\r\n\t\tthis._disposableObjectName = 'Lazy';\r\n\t\tthis._isValueCreated = false;\r\n\t}\r\n\r\n\tget isValueCreated():boolean\r\n\t{\r\n\t\treturn !!this._isValueCreated;\r\n\t}\r\n\r\n\tget value():T\r\n\t{\r\n\t\treturn this.getValue();\r\n\t}\r\n\r\n\tequals(other:Lazy<T>):boolean\r\n\t{\r\n\t\treturn this==other;\r\n\t}\r\n\r\n\tvalueEquals(other:Lazy<T>):boolean\r\n\t{\r\n\t\treturn this.equals(other) || this.value===other.value;\r\n\t}\r\n\r\n}\r\n\r\nexport default Lazy;"]}