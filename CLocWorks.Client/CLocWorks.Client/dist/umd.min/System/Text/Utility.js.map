{"version":3,"sources":["System/Text/Utility.js","System/Text/Utility.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","getHashCode","source","hash","length","i","l","ch","charCodeAt","repeat","count","result","EMPTY","isNaN","fromChars","chOrChars","Array","isArray","_i","chOrChars_1","char","String","fromCharCode","escapeRegExp","replace","trim","chars","ignoreCase","escaped","join","RegExp","format","args","arguments","supplant","params","oIsArray","a","b","n","parseInt","r","Types_1","Type","STRING","NUMBER","BOOLEAN","hasMemberOfType","FUNCTION","toString","canMatch","match","isString","startsWith","pattern","m","isBoolean","indexOf","endsWith","lastIndexOf"],"mappings":"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","file":"System/Text/Utility.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", \"../Types\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var Types_1 = require(\"../Types\");\n    exports.EMPTY = '';\n    var SPACE = ' ';\n    var ZERO = '0';\n    function getHashCode(source) {\n        var hash = 0 | 0;\n        if (source.length == 0)\n            return hash;\n        for (var i = 0, l = source.length; i < l; i++) {\n            var ch = source.charCodeAt(i);\n            hash = ((hash << 5) - hash) + ch;\n            hash |= 0;\n        }\n        return hash;\n    }\n    exports.getHashCode = getHashCode;\n    function repeat(source, count) {\n        var result = exports.EMPTY;\n        if (!isNaN(count)) {\n            for (var i = 0; i < count; i++) {\n                result += source;\n            }\n        }\n        return result;\n    }\n    exports.repeat = repeat;\n    function fromChars(chOrChars, count) {\n        if (count === void 0) { count = 1; }\n        if (Array.isArray(chOrChars)) {\n            var result = exports.EMPTY;\n            for (var _i = 0, chOrChars_1 = chOrChars; _i < chOrChars_1.length; _i++) {\n                var char = chOrChars_1[_i];\n                result += String.fromCharCode(char);\n            }\n            return result;\n        }\n        else {\n            return repeat(String.fromCharCode(chOrChars), count);\n        }\n    }\n    exports.fromChars = fromChars;\n    function escapeRegExp(source) {\n        return source.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n    }\n    exports.escapeRegExp = escapeRegExp;\n    function trim(source, chars, ignoreCase) {\n        if (chars === exports.EMPTY)\n            return source;\n        if (chars) {\n            var escaped = escapeRegExp(Array.isArray(chars) ? chars.join() : chars);\n            return source.replace(new RegExp('^[' + escaped + ']+|[' + escaped + ']+$', 'g' + (ignoreCase\n                ? 'i'\n                : '')), exports.EMPTY);\n        }\n        return source.replace(/^\\s+|\\s+$/g, exports.EMPTY);\n    }\n    exports.trim = trim;\n    function format(source) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        return supplant(source, args);\n    }\n    exports.format = format;\n    function supplant(source, params) {\n        var oIsArray = Array.isArray(params);\n        return source.replace(/\\{([^{}]*)\\}/g, function (a, b) {\n            var n = b;\n            if (oIsArray) {\n                var i = parseInt(b);\n                if (!isNaN(i))\n                    n = i;\n            }\n            var r = params[n];\n            switch (typeof r) {\n                case Types_1.Type.STRING:\n                case Types_1.Type.NUMBER:\n                case Types_1.Type.BOOLEAN:\n                    return r;\n                default:\n                    return (r && Types_1.Type.hasMemberOfType(r, \"toString\", Types_1.Type.FUNCTION))\n                        ? r.toString()\n                        : a;\n            }\n        });\n    }\n    exports.supplant = supplant;\n    function canMatch(source, match) {\n        if (!Types_1.Type.isString(source) || !match)\n            return false;\n        if (source === match)\n            return true;\n        if (match.length < source.length)\n            return null;\n    }\n    function startsWith(source, pattern) {\n        var m = canMatch(source, pattern);\n        return Types_1.Type.isBoolean(m) ? m : source.indexOf(pattern) == 0;\n    }\n    exports.startsWith = startsWith;\n    function endsWith(source, pattern) {\n        var m = canMatch(source, pattern);\n        return Types_1.Type.isBoolean(m) ? m : source.lastIndexOf(pattern) == (source.length - pattern.length);\n    }\n    exports.endsWith = endsWith;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {Type} from \"../Types\";\r\n\r\nexport const EMPTY:string = '';\r\nconst SPACE = ' ';\r\nconst ZERO = '0';\r\n\r\n/**\r\n * Returns a numerical (integer) hash code of the string.  Can be used for identifying inequality of contents, but two different strings in rare cases will have the same hash code.\r\n * @param source\r\n * @returns {number}\r\n */\r\nexport function getHashCode(source:string):number\r\n{\r\n\tvar hash = 0 | 0;\r\n\tif(source.length==0) return hash;\r\n\tfor(let i = 0, l = source.length; i<l; i++)\r\n\t{\r\n\t\tlet ch = source.charCodeAt(i);\r\n\t\thash = ((hash<<5) - hash) + ch;\r\n\t\thash |= 0; // Convert to 32bit integer\r\n\t}\r\n\treturn hash;\r\n}\r\n\r\nexport function repeat(source:string, count:number):string\r\n{\r\n\tvar result = EMPTY;\r\n\tif(!isNaN(count))\r\n\t{\r\n\t\tfor(let i = 0; i<count; i++)\r\n\t\t{\r\n\t\t\tresult += source;\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nexport function fromChars(ch:number, count:number):string\r\nexport function fromChars(chars:number[]):string\r\nexport function fromChars(chOrChars:any, count:number = 1):string\r\n{\r\n\tif(Array.isArray(chOrChars))\r\n\t{\r\n\t\tlet result = EMPTY;\r\n\t\tfor(let char of chOrChars)\r\n\t\t{\r\n\t\t\tresult += String.fromCharCode(char);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\telse\r\n\t{\r\n\t\treturn repeat(String.fromCharCode(chOrChars), count);\r\n\t}\r\n}\r\n\r\n/**\r\n * Escapes a RegExp sequence.\r\n * @param source\r\n * @returns {string}\r\n */\r\nexport function escapeRegExp(source:string):string\r\n{\r\n\treturn source.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\r\n}\r\n\r\n/**\r\n * Can trim any character or set of characters from the ends of a string.\r\n * Uses a Regex escapement to replace them with empty.\r\n * @param source\r\n * @param chars A string or array of characters desired to be trimmed.\r\n * @param ignoreCase\r\n * @returns {string}\r\n */\r\nexport function trim(source:string, chars?:string|string[], ignoreCase?:boolean):string\r\n{\r\n\tif(chars===EMPTY) return source;\r\n\tif(chars)\r\n\t{\r\n\t\tvar escaped = escapeRegExp(Array.isArray(chars) ? chars.join() : <string>chars);\r\n\t\treturn source.replace(new RegExp('^[' + escaped + ']+|[' + escaped + ']+$', 'g' + (ignoreCase\r\n\t\t\t\t? 'i'\r\n\t\t\t\t: '')), EMPTY);\r\n\t}\r\n\r\n\treturn source.replace(/^\\s+|\\s+$/g, EMPTY);\r\n}\r\n\r\n/**\r\n * Takes any arg\r\n * @param source\r\n * @param args\r\n * @returns {string}\r\n */\r\nexport function format(source:string, ...args:any[])\r\n{\r\n\treturn supplant(source, args);\r\n}\r\n\r\n//\r\n\r\n/**\r\n * This takes a string and replaces '{string}' with the respected parameter.\r\n * Also allows for passing an array in order to use '{n}' notation.\r\n * Not limited to an array's indexes.  For example, {length} is allowed.\r\n * Based upon Crockford's supplant function.\r\n * @param source\r\n * @param params\r\n * @returns {string}\r\n */\r\nexport function supplant(source:string, params:{[key:string]:any}|any[]):string\r\n{\r\n\tvar oIsArray = Array.isArray(params);\r\n\treturn source.replace(/\\{([^{}]*)\\}/g,\r\n\t\t(a:string, b:string):any=>\r\n\t\t{\r\n\t\t\tvar n:any = b;\r\n\t\t\tif(oIsArray)\r\n\t\t\t{\r\n\t\t\t\tlet i = parseInt(b);\r\n\t\t\t\tif(!isNaN(i)) n = i;\r\n\t\t\t}\r\n\r\n\t\t\tvar r = (<any>params)[n];\r\n\t\t\tswitch(typeof r)\r\n\t\t\t{\r\n\t\t\t\tcase Type.STRING:\r\n\t\t\t\tcase Type.NUMBER:\r\n\t\t\t\tcase Type.BOOLEAN:\r\n\t\t\t\t\treturn r;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn (r && Type.hasMemberOfType(r, \"toString\", Type.FUNCTION))\r\n\t\t\t\t\t\t? r.toString()\r\n\t\t\t\t\t\t: a;\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n}\r\n\r\n\r\nfunction canMatch(source:string, match:string):boolean\r\n{\r\n\tif(!Type.isString(source) || !match) return false;\r\n\tif(source===match) return true;\r\n\tif(match.length<source.length) return null;\r\n}\r\n\r\n/**\r\n * Returns true if the pattern matches the beginning of the source.\r\n * @param source\r\n * @param pattern\r\n * @returns {boolean}\r\n */\r\nexport function startsWith(source:string, pattern:string):boolean\r\n{\r\n\tvar m = canMatch(source, pattern);\r\n\treturn Type.isBoolean(m) ? m : source.indexOf(pattern)==0;\r\n}\r\n\r\n/**\r\n * Returns true if the pattern matches the end of the source.\r\n * @param source\r\n * @param pattern\r\n * @returns {boolean}\r\n */\r\nexport function endsWith(source:string, pattern:string):boolean\r\n{\r\n\tvar m = canMatch(source, pattern);\r\n\treturn Type.isBoolean(m) ? m : source.lastIndexOf(pattern)==(source.length - pattern.length);\r\n}\r\n\r\n"]}