{"version":3,"sources":["System/Promises/LazyPromise.js","System/Promises/LazyPromise.ts"],"names":["__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","factory","module","exports","v","require","undefined","define","amd","Promise_1","defer_1","ArgumentNullException_1","VOID0","LazyPromise","_super","_resolver","call","ArgumentNullException","_resolvedCalled","_onDispose","_onThen","r","resolveUsing","thenSynchronous","onFulfilled","onRejected","thenThis","delayFromNow","milliseconds","_this","throwIfDisposed","isSettled","pass","timedOut","timeout","defer","resolve","reject","e","dispose","delayAfterResolve","finalize","detector","isPending","Promise","defineProperty","value"],"mappings":"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","file":"System/Promises/LazyPromise.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT\n */\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", \"./Promise\", \"../Threading/defer\", \"../Exceptions/ArgumentNullException\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var Promise_1 = require(\"./Promise\");\n    var defer_1 = require(\"../Threading/defer\");\n    var ArgumentNullException_1 = require(\"../Exceptions/ArgumentNullException\");\n    var VOID0 = void 0;\n    var LazyPromise = (function (_super) {\n        __extends(LazyPromise, _super);\n        function LazyPromise(_resolver) {\n            _super.call(this);\n            this._resolver = _resolver;\n            if (!_resolver)\n                throw new ArgumentNullException_1.ArgumentNullException(\"resolver\");\n            this._resolvedCalled = true;\n        }\n        LazyPromise.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._resolver = VOID0;\n        };\n        LazyPromise.prototype._onThen = function () {\n            var r = this._resolver;\n            if (r) {\n                this._resolver = VOID0;\n                this._resolvedCalled = false;\n                this.resolveUsing(r);\n            }\n        };\n        LazyPromise.prototype.thenSynchronous = function (onFulfilled, onRejected) {\n            this._onThen();\n            return _super.prototype.thenSynchronous.call(this, onFulfilled, onRejected);\n        };\n        LazyPromise.prototype.thenThis = function (onFulfilled, onRejected) {\n            this._onThen();\n            return _super.prototype.thenThis.call(this, onFulfilled, onRejected);\n        };\n        LazyPromise.prototype.delayFromNow = function (milliseconds) {\n            var _this = this;\n            if (milliseconds === void 0) { milliseconds = 0; }\n            this.throwIfDisposed();\n            if (!this._resolver || this.isSettled)\n                return _super.prototype.delayFromNow.call(this, milliseconds);\n            var pass;\n            var timedOut = false;\n            var timeout = defer_1.defer(function () {\n                timedOut = true;\n                if (pass)\n                    pass();\n            }, milliseconds);\n            return new LazyPromise(function (resolve, reject) {\n                pass = function () {\n                    _this.thenThis(function (v) { return resolve(v); }, function (e) { return reject(e); });\n                    timeout.dispose();\n                    timeout = null;\n                    pass = null;\n                };\n                if (timedOut)\n                    pass();\n            });\n        };\n        LazyPromise.prototype.delayAfterResolve = function (milliseconds) {\n            var _this = this;\n            if (milliseconds === void 0) { milliseconds = 0; }\n            this.throwIfDisposed();\n            if (!this._resolver || this.isSettled)\n                return _super.prototype.delayAfterResolve.call(this, milliseconds);\n            var pass;\n            var timeout;\n            var finalize = function () {\n                if (timeout) {\n                    timeout.dispose();\n                    timeout = null;\n                }\n                if (pass)\n                    pass();\n                finalize = null;\n            };\n            {\n                var detector = function () {\n                    if (finalize)\n                        timeout = defer_1.defer(finalize, milliseconds);\n                };\n                _super.prototype.thenThis.call(this, detector, detector);\n                detector = null;\n            }\n            return new LazyPromise(function (resolve, reject) {\n                if (_this.isPending) {\n                    _this.thenThis(function (v) { return defer_1.defer(function () { return resolve(v); }, milliseconds); }, function (e) { return defer_1.defer(function () { return reject(e); }, milliseconds); });\n                    finalize();\n                }\n                else {\n                    pass = function () {\n                        _this.thenThis(function (v) { return resolve(v); }, function (e) { return reject(e); });\n                    };\n                    if (!finalize)\n                        pass();\n                }\n            });\n        };\n        return LazyPromise;\n    }(Promise_1.Promise));\n    exports.LazyPromise = LazyPromise;\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = LazyPromise;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT\r\n */\r\n\r\nimport {Promise, PromiseBase} from \"./Promise\";\r\nimport {Closure} from \"../FunctionTypes\";\r\nimport {ICancellable} from \"../Threading/ICancellable\";\r\nimport {defer} from \"../Threading/defer\";\r\nimport {ArgumentNullException} from \"../Exceptions/ArgumentNullException\";\r\n\r\nconst VOID0:any = void 0;\r\n\r\n/**\r\n * A promise that waits for the first then to trigger the resolver.\r\n */\r\nexport class LazyPromise<T> extends Promise<T>\r\n{\r\n\r\n\tconstructor(private _resolver:Promise.Executor<T>)\r\n\t{\r\n\t\tsuper();\r\n\t\tif(!_resolver) throw new ArgumentNullException(\"resolver\");\r\n\t\tthis._resolvedCalled = true;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._resolver = VOID0;\r\n\t}\r\n\r\n\tprivate _onThen():void\r\n\t{\r\n\t\tvar r = this._resolver;\r\n\t\tif(r)\r\n\t\t{\r\n\t\t\tthis._resolver = VOID0;\r\n\t\t\tthis._resolvedCalled = false;\r\n\t\t\tthis.resolveUsing(r);\r\n\t\t}\r\n\t}\r\n\r\n\tthenSynchronous<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T, TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis._onThen();\r\n\t\treturn super.thenSynchronous(onFulfilled, onRejected);\r\n\t}\r\n\r\n\r\n\tthenThis(\r\n\t\tonFulfilled:(v?:T)=>any,\r\n\t\tonRejected?:(v?:any)=>any):PromiseBase<T>\r\n\t{\r\n\t\tthis._onThen();\r\n\t\treturn super.thenThis(onFulfilled, onRejected);\r\n\t}\r\n\r\n\t// NOTE: For a LazyPromise we need to be careful not to trigger the resolve for delay.\r\n\r\n\t/**\r\n\t * Will yield for a number of milliseconds from the time called before continuing.\r\n\t * @param milliseconds\r\n\t * @returns A promise that yields to the current execution and executes after a minimum delay.\r\n\t */\r\n\tdelayFromNow(milliseconds:number = 0):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\t// If this is already guaranteed to resolve, the go ahead and pass to the super.\r\n\t\tif(!this._resolver || this.isSettled)\r\n\t\t\treturn super.delayFromNow(milliseconds);\r\n\r\n\t\t/*\r\n\t\t * If not triggered yet, then we create a special promise\r\n\t\t * that only requests the resolution from the parent promise\r\n\t\t * if a 'then' is called to ensure the lazy pattern.\r\n\t\t */\r\n\t\tvar pass:Closure;\r\n\t\tvar timedOut:boolean = false;\r\n\r\n\t\t// Setup the timer.\r\n\t\tvar timeout = defer(()=>\r\n\t\t\t{\r\n\t\t\t\ttimedOut = true;\r\n\t\t\t\t// If the promise was requested already go ahead and pass the request on to the parent.\r\n\t\t\t\tif(pass)\r\n\t\t\t\t\tpass();\r\n\t\t\t},\r\n\t\t\tmilliseconds);\r\n\r\n\t\treturn new LazyPromise<T>(\r\n\t\t\t(resolve, reject)=>\r\n\t\t\t{\r\n\t\t\t\t// A lazy promise only enters here if something called for a resolution.\r\n\t\t\t\tpass = ()=>\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.thenThis(\r\n\t\t\t\t\t\tv=> resolve(v),\r\n\t\t\t\t\t\te=> reject(e)\r\n\t\t\t\t\t);\r\n\t\t\t\t\ttimeout.dispose();\r\n\t\t\t\t\ttimeout = null;\r\n\t\t\t\t\tpass = null;\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// If the timeout completed already go ahead and pass the request on to the parent.\r\n\t\t\t\tif(timedOut)\r\n\t\t\t\t\tpass();\r\n\t\t\t\t// Otherwise wait for the timeout to do it.\r\n\t\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Will yield for a number of milliseconds from after this promise resolves.\r\n\t * If the promise is already resolved, the delay will start from now.\r\n\t * @param milliseconds\r\n\t * @returns A promise that yields to the current execution and executes after a delay.\r\n\t */\r\n\tdelayAfterResolve(milliseconds:number = 0):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\t// If this is already guaranteed to resolve, the go ahead and pass to the super.\r\n\t\tif(!this._resolver || this.isSettled)\r\n\t\t\treturn super.delayAfterResolve(milliseconds);\r\n\r\n\t\t/*\r\n\t\t * If not triggered yet, then we create a special promise\r\n\t\t * that only requests the resolution from the parent promise\r\n\t\t * if a 'then' is called to ensure the lazy pattern.\r\n\t\t */\r\n\t\tvar pass:Closure;\r\n\r\n\r\n\t\t// Setup the timer.\r\n\t\tvar timeout:ICancellable;\r\n\r\n\t\tvar finalize = ()=>\r\n\t\t{\r\n\t\t\tif(timeout)\r\n\t\t\t{\r\n\t\t\t\ttimeout.dispose();\r\n\t\t\t\ttimeout = null;\r\n\t\t\t}\r\n\t\t\t// If the promise was requested already go ahead and pass the request on to the parent.\r\n\t\t\tif(pass)\r\n\t\t\t\tpass();\r\n\r\n\t\t\tfinalize = null;\r\n\t\t};\r\n\r\n\t\t{\r\n\t\t\tlet detector = ()=>\r\n\t\t\t{\r\n\t\t\t\tif(finalize) // We may already be wrapped up so never mind!\r\n\t\t\t\t\ttimeout = defer(finalize, milliseconds);\r\n\t\t\t};\r\n\r\n\t\t\t// Calling super.thenThis does not trigger resolution.\r\n\t\t\t// This simply waits for resolution to happen.\r\n\t\t\t// Is effectively the timer by when resolution has occurred.\r\n\t\t\tsuper.thenThis(detector, detector);\r\n\t\t\tdetector = null;\r\n\t\t}\r\n\r\n\t\treturn new LazyPromise<T>(\r\n\t\t\t(resolve, reject)=>\r\n\t\t\t{\r\n\t\t\t\t// Because of the lazy nature of this promise, this could enter here at any time.\r\n\t\t\t\tif(this.isPending)\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.thenThis(\r\n\t\t\t\t\t\tv=> defer(()=>resolve(v), milliseconds),\r\n\t\t\t\t\t\te=> defer(()=>reject(e), milliseconds)\r\n\t\t\t\t\t);\r\n\t\t\t\t\tfinalize();\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// We don't know when this resolved and could have happened anytime after calling this delay method.\r\n\t\t\t\t\tpass = ()=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis.thenThis(\r\n\t\t\t\t\t\t\tv=> resolve(v),\r\n\t\t\t\t\t\t\te=> reject(e)\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Already finalized (aka resolved after a timeout)? Go now!\r\n\t\t\t\t\tif(!finalize)\r\n\t\t\t\t\t\tpass();\r\n\t\t\t\t}\r\n\r\n\t\t\t});\r\n\r\n\t}\r\n}\r\n\r\nexport default LazyPromise;"]}