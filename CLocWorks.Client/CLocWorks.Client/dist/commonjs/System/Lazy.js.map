{"version":3,"sources":["System/Lazy.js","System/Lazy.ts"],"names":[],"mappings":";;;;AAIA;;;;;;;;;;ACGA,IAAA,iBAAA,QAA2B,gBAA3B,CAAA;;IAGA;;;AAGC,aAHD,IAGC,CAAY,YAAZ,EAA4F;YAA1D,uEAAyB,qBAAiC;YAA1B,mEAAqB,qBAAK;;8BAH7F,MAG6F;;2EAH7F,iBAKQ,cAAc,gBAAgB,aAFuD;;AAG3F,cAAK,qBAAL,GAA6B,MAA7B,CAH2F;AAI3F,cAAK,eAAL,GAAuB,KAAvB,CAJ2F;;KAA5F;;iBAHD;;+BAoBQ,OAAa;AAEnB,mBAAO,QAAM,KAAN,CAFY;;;;oCAKR,OAAa;AAExB,mBAAO,KAAK,MAAL,CAAY,KAAZ,KAAsB,KAAK,KAAL,KAAa,MAAM,KAAN,CAFlB;;;;4BAfP;AAEjB,mBAAO,CAAC,CAAC,KAAK,eAAL,CAFQ;;;;4BAKT;AAER,mBAAO,KAAK,QAAL,EAAP,CAFQ;;;;WAfV;EAA6B,eAAA,YAAA;;AAAhB,QAAA,IAAA,GAAI,IAAJ;AAgCb,OAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA,EAAA,OAAA,IAAA,EAAA;ADfA,QAAQ,OAAR,GCee,IDff","file":"System/Lazy.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst ResolverBase_1 = require(\"./ResolverBase\");\nclass Lazy extends ResolverBase_1.ResolverBase {\n    constructor(valueFactory, trapExceptions = false, allowReset = false) {\n        super(valueFactory, trapExceptions, allowReset);\n        this._disposableObjectName = 'Lazy';\n        this._isValueCreated = false;\n    }\n    get isValueCreated() {\n        return !!this._isValueCreated;\n    }\n    get value() {\n        return this.getValue();\n    }\n    equals(other) {\n        return this == other;\n    }\n    valueEquals(other) {\n        return this.equals(other) || this.value === other.value;\n    }\n}\nexports.Lazy = Lazy;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Lazy;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {ILazy} from \"./ILazy\";\r\nimport {Func} from \"./FunctionTypes\";\r\nimport {ResolverBase} from \"./ResolverBase\";\r\n\r\n// We need a non-resettable lazy to ensure it can be passed safely around.\r\nexport class Lazy<T> extends ResolverBase<T> implements ILazy<T>\r\n{\r\n\r\n\tconstructor(valueFactory:Func<T>, trapExceptions:boolean = false, allowReset:boolean = false)\r\n\t{\r\n\t\tsuper(valueFactory, trapExceptions, allowReset);\r\n\t\tthis._disposableObjectName = 'Lazy';\r\n\t\tthis._isValueCreated = false;\r\n\t}\r\n\r\n\tget isValueCreated():boolean\r\n\t{\r\n\t\treturn !!this._isValueCreated;\r\n\t}\r\n\r\n\tget value():T\r\n\t{\r\n\t\treturn this.getValue();\r\n\t}\r\n\r\n\tequals(other:Lazy<T>):boolean\r\n\t{\r\n\t\treturn this==other;\r\n\t}\r\n\r\n\tvalueEquals(other:Lazy<T>):boolean\r\n\t{\r\n\t\treturn this.equals(other) || this.value===other.value;\r\n\t}\r\n\r\n}\r\n\r\nexport default Lazy;"]}