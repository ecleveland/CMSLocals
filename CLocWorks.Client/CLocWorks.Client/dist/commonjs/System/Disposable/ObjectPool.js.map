{"version":3,"sources":["System/Disposable/ObjectPool.js","System/Disposable/ObjectPool.ts"],"names":[],"mappings":"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","file":"System/Disposable/ObjectPool.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n * Based upon ObjectPool from Parallel Extension Extras and other ObjectPool implementations.\n * Uses .add(T) and .take():T\n */\n\"use strict\";\nconst dispose_1 = require(\"./dispose\");\nconst DisposableBase_1 = require(\"./DisposableBase\");\nconst TaskHandler_1 = require(\"../Threading/Tasks/TaskHandler\");\nconst ArgumentOutOfRangeException_1 = require(\"../Exceptions/ArgumentOutOfRangeException\");\nconst OBJECT_POOL = \"ObjectPool\", _MAX_SIZE = \"_maxSize\", ABSOLUTE_MAX_SIZE = 65536, MUST_BE_GT1 = \"Must be at valid number least 1.\", MUST_BE_LTM = `Must be less than or equal to ${ABSOLUTE_MAX_SIZE}.`;\nclass ObjectPool extends DisposableBase_1.DisposableBase {\n    constructor(_maxSize, _generator, _recycler) {\n        super();\n        this._maxSize = _maxSize;\n        this._generator = _generator;\n        this._recycler = _recycler;\n        this.autoClearTimeout = 5000;\n        if (isNaN(_maxSize) || _maxSize < 1)\n            throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(_MAX_SIZE, _maxSize, MUST_BE_GT1);\n        if (_maxSize > ABSOLUTE_MAX_SIZE)\n            throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(_MAX_SIZE, _maxSize, MUST_BE_LTM);\n        this._localAbsMaxSize = Math.min(_maxSize * 2, ABSOLUTE_MAX_SIZE);\n        var _ = this;\n        _._disposableObjectName = OBJECT_POOL;\n        _._pool = [];\n        _._trimmer = new TaskHandler_1.TaskHandler(() => _._trim());\n        var clear = () => _._clear();\n        _._flusher = new TaskHandler_1.TaskHandler(clear);\n        _._autoFlusher = new TaskHandler_1.TaskHandler(clear);\n    }\n    get maxSize() {\n        return this._maxSize;\n    }\n    get count() {\n        var p = this._pool;\n        return p ? p.length : 0;\n    }\n    _trim() {\n        var pool = this._pool;\n        while (pool.length > this._maxSize) {\n            dispose_1.dispose.withoutException(pool.pop());\n        }\n    }\n    trim(defer) {\n        this.throwIfDisposed();\n        this._trimmer.start(defer);\n    }\n    _clear() {\n        var _ = this, p = _._pool;\n        _._trimmer.cancel();\n        _._flusher.cancel();\n        _._autoFlusher.cancel();\n        dispose_1.dispose.these(p, true);\n        p.length = 0;\n    }\n    clear(defer) {\n        this.throwIfDisposed();\n        this._flusher.start(defer);\n    }\n    toArrayAndClear() {\n        var _ = this;\n        _.throwIfDisposed();\n        _._trimmer.cancel();\n        _._flusher.cancel();\n        var p = _._pool;\n        _._pool = [];\n        return p;\n    }\n    dump() {\n        return this.toArrayAndClear();\n    }\n    _onDispose() {\n        super._onDispose();\n        var _ = this;\n        _._generator = null;\n        _._recycler = null;\n        dispose_1.dispose(_._trimmer, _._flusher, _._autoFlusher);\n        _._trimmer = null;\n        _._flusher = null;\n        _._autoFlusher = null;\n        _._pool.length = 0;\n        _._pool = null;\n    }\n    extendAutoClear() {\n        var _ = this;\n        _.throwIfDisposed();\n        var t = _.autoClearTimeout;\n        if (isFinite(t) && !_._autoFlusher.isScheduled)\n            _._autoFlusher.start(t);\n    }\n    add(o) {\n        var _ = this;\n        _.throwIfDisposed();\n        if (_._pool.length >= _._localAbsMaxSize) {\n            dispose_1.dispose(o);\n        }\n        else {\n            if (_._recycler)\n                _._recycler(o);\n            _._pool.push(o);\n            var m = _._maxSize;\n            if (m < ABSOLUTE_MAX_SIZE && _._pool.length > m)\n                _._trimmer.start(500);\n        }\n        _.extendAutoClear();\n    }\n    take() {\n        var _ = this;\n        _.throwIfDisposed();\n        var e = _._pool.pop() || _._generator(), len = _._pool.length;\n        if (_._pool.length <= _._maxSize)\n            _._trimmer.cancel();\n        if (len)\n            _.extendAutoClear();\n        return e;\n    }\n}\nexports.ObjectPool = ObjectPool;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ObjectPool;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Based upon ObjectPool from Parallel Extension Extras and other ObjectPool implementations.\r\n * Uses .add(T) and .take():T\r\n */\r\n\r\nimport {dispose} from \"./dispose\";\r\nimport {DisposableBase} from \"./DisposableBase\";\r\nimport {TaskHandler} from \"../Threading/Tasks/TaskHandler\";\r\nimport {ArgumentOutOfRangeException} from \"../Exceptions/ArgumentOutOfRangeException\";\r\n\r\nconst\r\n\tOBJECT_POOL       = \"ObjectPool\",\r\n\t_MAX_SIZE         = \"_maxSize\",\r\n\tABSOLUTE_MAX_SIZE = 65536,\r\n\tMUST_BE_GT1       = \"Must be at valid number least 1.\",\r\n\tMUST_BE_LTM       = `Must be less than or equal to ${ABSOLUTE_MAX_SIZE}.`;\r\n\r\nexport class ObjectPool<T> extends DisposableBase\r\n{\r\n\r\n\tprivate _pool:T[];\r\n\tprivate _trimmer:TaskHandler;\r\n\tprivate _flusher:TaskHandler;\r\n\tprivate _autoFlusher:TaskHandler;\r\n\r\n\t/**\r\n\t * A transient amount of object to exist over _maxSize until trim() is called.\r\n\t * But any added objects over _localAbsMaxSize will be disposed immediately.\r\n\t */\r\n\tprivate _localAbsMaxSize:number;\r\n\r\n\t/**\r\n\t * By default will clear after 5 seconds of non-use.\r\n\t */\r\n\tautoClearTimeout:number = 5000;\r\n\r\n\tconstructor(\r\n\t\tprivate _maxSize:number,\r\n\t\tprivate _generator:(...args:any[])=>T,\r\n\t\tprivate _recycler?:(o:T)=>void)\r\n\t{\r\n\t\tsuper();\r\n\t\tif(isNaN(_maxSize) || _maxSize<1)\r\n\t\t\tthrow new ArgumentOutOfRangeException(_MAX_SIZE, _maxSize, MUST_BE_GT1);\r\n\t\tif(_maxSize>ABSOLUTE_MAX_SIZE)\r\n\t\t\tthrow new ArgumentOutOfRangeException(_MAX_SIZE, _maxSize, MUST_BE_LTM);\r\n\r\n\t\tthis._localAbsMaxSize = Math.min(_maxSize*2, ABSOLUTE_MAX_SIZE);\r\n\r\n\t\tvar _ = this;\r\n\t\t_._disposableObjectName = OBJECT_POOL;\r\n\t\t_._pool = [];\r\n\t\t_._trimmer = new TaskHandler(()=>_._trim());\r\n\t\tvar clear = ()=>_._clear();\r\n\t\t_._flusher = new TaskHandler(clear);\r\n\t\t_._autoFlusher = new TaskHandler(clear);\r\n\t}\r\n\r\n\t/**\r\n\t * Defines the maximum at which trimming should allow.\r\n\t * @returns {number}\r\n\t */\r\n\tget maxSize():number\r\n\t{\r\n\t\treturn this._maxSize;\r\n\t}\r\n\r\n\t/**\r\n\t * Current number of objects in pool.\r\n\t * @returns {number}\r\n\t */\r\n\tget count():number\r\n\t{\r\n\t\tvar p = this._pool;\r\n\t\treturn p ? p.length : 0;\r\n\t}\r\n\r\n\tprotected _trim():void\r\n\t{\r\n\t\tvar pool = this._pool;\r\n\t\twhile(pool.length>this._maxSize)\r\n\t\t{\r\n\t\t\tdispose.withoutException(<any>pool.pop());\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Will trim ensure the pool is less than the maxSize.\r\n\t * @param defer A delay before trimming.  Will be overridden by later calls.\r\n\t */\r\n\ttrim(defer?:number):void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tthis._trimmer.start(defer);\r\n\t}\r\n\r\n\tprotected _clear():void\r\n\t{\r\n\t\tvar _ = this, p = _._pool;\r\n\t\t_._trimmer.cancel();\r\n\t\t_._flusher.cancel();\r\n\t\t_._autoFlusher.cancel();\r\n\t\tdispose.these(<any>p, true);\r\n\t\tp.length = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Will clear out the pool.\r\n\t * Cancels any scheduled trims when executed.\r\n\t * @param defer A delay before clearing.  Will be overridden by later calls.\r\n\t */\r\n\tclear(defer?:number):void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tthis._flusher.start(defer);\r\n\t}\r\n\r\n\ttoArrayAndClear():T[]\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\t_._trimmer.cancel();\r\n\t\t_._flusher.cancel();\r\n\t\tvar p = _._pool;\r\n\t\t_._pool = [];\r\n\t\treturn p;\r\n\t}\r\n\r\n\t/**\r\n\t * Shortcut for toArrayAndClear();\r\n\t */\r\n\tdump():T[]\r\n\t{\r\n\t\treturn this.toArrayAndClear();\r\n\t}\r\n\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tvar _ = this;\r\n\t\t_._generator = null;\r\n\t\t_._recycler = null;\r\n\t\tdispose(\r\n\t\t\t_._trimmer,\r\n\t\t\t_._flusher,\r\n\t\t\t_._autoFlusher\r\n\t\t);\r\n\t\t_._trimmer = null;\r\n\t\t_._flusher = null;\r\n\t\t_._autoFlusher = null;\r\n\r\n\t\t_._pool.length = 0;\r\n\t\t_._pool = null;\r\n\t}\r\n\r\n\textendAutoClear():void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\tvar t = _.autoClearTimeout;\r\n\t\tif(isFinite(t) && !_._autoFlusher.isScheduled)\r\n\t\t\t_._autoFlusher.start(t);\r\n\t}\r\n\r\n\tadd(o:T):void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\tif(_._pool.length>=_._localAbsMaxSize)\r\n\t\t{\r\n\t\t\t// Getting too big, dispose immediately...\r\n\t\t\tdispose(<any>o);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(_._recycler) _._recycler(o);\r\n\t\t\t_._pool.push(o);\r\n\t\t\tvar m = _._maxSize;\r\n\t\t\tif(m<ABSOLUTE_MAX_SIZE && _._pool.length>m)\r\n\t\t\t\t_._trimmer.start(500);\r\n\t\t}\r\n\t\t_.extendAutoClear();\r\n\r\n\t}\r\n\r\n\ttake():T\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tvar e   = _._pool.pop() || _._generator(),\r\n\t\t    len = _._pool.length;\r\n\r\n\t\tif(_._pool.length<=_._maxSize)\r\n\t\t\t_._trimmer.cancel();\r\n\t\tif(len)\r\n\t\t\t_.extendAutoClear();\r\n\r\n\t\treturn e;\r\n\t}\r\n\r\n\r\n}\r\n\r\nexport default ObjectPool;\r\n"]}