{"version":3,"sources":["System/Disposable/dispose.js","System/Disposable/dispose.ts"],"names":[],"mappings":"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","file":"System/Disposable/dispose.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst Types_1 = require(\"../Types\");\nfunction dispose(...disposables) {\n    disposeTheseInternal(disposables, false);\n}\nexports.dispose = dispose;\nvar dispose;\n(function (dispose) {\n    function deferred(...disposables) {\n        these.deferred(disposables);\n    }\n    dispose.deferred = deferred;\n    function withoutException(...disposables) {\n        return disposeTheseInternal(disposables, true);\n    }\n    dispose.withoutException = withoutException;\n    function these(disposables, trapExceptions) {\n        return disposables && disposables.length\n            ? disposeTheseInternal(disposables.slice(), trapExceptions)\n            : null;\n    }\n    dispose.these = these;\n    var these;\n    (function (these) {\n        function deferred(disposables, delay = 0) {\n            if (disposables && disposables.length) {\n                if (!(delay >= 0))\n                    delay = 0;\n                setTimeout(disposeTheseInternal, delay, disposables.slice(), true);\n            }\n        }\n        these.deferred = deferred;\n    })(these = dispose.these || (dispose.these = {}));\n})(dispose = exports.dispose || (exports.dispose = {}));\nfunction using(disposable, closure) {\n    try {\n        return closure(disposable);\n    }\n    finally {\n        disposeSingle(disposable, false);\n    }\n}\nexports.using = using;\nfunction disposeSingle(disposable, trapExceptions) {\n    if (disposable && Types_1.Type.of(disposable).member('dispose').isFunction) {\n        if (trapExceptions) {\n            try {\n                disposable.dispose();\n            }\n            catch (ex) {\n                return ex;\n            }\n        }\n        else\n            disposable.dispose();\n    }\n    return null;\n}\nfunction disposeTheseInternal(disposables, trapExceptions, index = 0) {\n    var exceptions;\n    var len = disposables.length;\n    for (; index < len; index++) {\n        var next = disposables[index];\n        if (!next)\n            continue;\n        if (trapExceptions) {\n            var ex = disposeSingle(next, true);\n            if (ex) {\n                if (!exceptions)\n                    exceptions = [];\n                exceptions.push(ex);\n            }\n        }\n        else {\n            var success = false;\n            try {\n                disposeSingle(next, false);\n                success = true;\n            }\n            finally {\n                if (!success && index + 1 < len) {\n                    disposeTheseInternal(disposables, false, index + 1);\n                }\n            }\n            if (!success)\n                break;\n        }\n    }\n    return exceptions;\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = dispose;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {Type} from \"../Types\";\r\nimport {IDisposable} from \"./IDisposable\";\r\n\r\n/**\r\n * Takes any number of disposables as arguments and attempts to dispose them.\r\n * Any exceptions thrown within a dispose are not trapped.\r\n * Use 'disposeWithoutException' to automatically trap exceptions.\r\n *\r\n * Can accept <any> and will ignore objects that don't have a dispose() method.\r\n * @param disposables\r\n */\r\nexport function dispose(...disposables:IDisposable[]):void\r\n{\r\n\t// The disposables arguments array is effectively localized so it's safe.\r\n\tdisposeTheseInternal(disposables, false);\r\n}\r\n\r\nexport module dispose {\r\n\r\n\texport function deferred(...disposables:IDisposable[]):void {\r\n\t\tthese.deferred(disposables);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Takes any number of disposables and traps any errors that occur when disposing.\r\n\t * Returns an array of the exceptions thrown.\r\n\t * @param disposables\r\n\t * @returns {any[]} Returns an array of exceptions that occurred, if there are any.\r\n\t */\r\n\texport function withoutException(...disposables:IDisposable[]):any[]\r\n\t{\r\n\t\t// The disposables arguments array is effectively localized so it's safe.\r\n\t\treturn disposeTheseInternal(disposables, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Takes an array of disposable objects and ensures they are disposed.\r\n\t * @param disposables\r\n\t * @param trapExceptions If true, prevents exceptions from being thrown when disposing.\r\n\t * @returns {any[]} If 'trapExceptions' is true, returns an array of exceptions that occurred, if there are any.\r\n\t */\r\n\texport function these(disposables:IDisposable[], trapExceptions?:boolean):any[]\r\n\t{\r\n\t\treturn disposables && disposables.length\r\n\t\t\t? disposeTheseInternal(disposables.slice(), trapExceptions)\r\n\t\t\t: null;\r\n\t}\r\n\r\n\texport module these {\r\n\t\texport function deferred(disposables:IDisposable[], delay:number = 0):void {\r\n\t\t\tif(disposables && disposables.length) {\r\n\t\t\t\tif(!(delay>=0)) delay = 0;\r\n\t\t\t\tsetTimeout(disposeTheseInternal,delay,disposables.slice(), true);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Just like in C# this 'using' function will ensure the passed disposable is disposed when the closure has finished.\r\n *\r\n * Usage:\r\n * ```typescript\r\n * using(new DisposableObject(),(myObj)=>{\r\n     *   // do work with myObj\r\n     * });\r\n * // myObj automatically has it's dispose method called.\r\n * ```\r\n *\r\n * @param disposable Object to be disposed.\r\n * @param closure Function call to execute.\r\n * @returns {TReturn} Returns whatever the closure's return value is.\r\n */\r\nexport function using<TDisposable extends IDisposable,TReturn>(\r\n\tdisposable:TDisposable,\r\n\tclosure:(disposable:TDisposable) => TReturn):TReturn\r\n{\r\n\ttry\r\n\t{\r\n\t\treturn closure(disposable);\r\n\t}\r\n\tfinally\r\n\t{\r\n\t\tdisposeSingle(disposable, false);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * This private function makes disposing more robust for when there's no type checking.\r\n * If trapExceptions is 'true' it catches and returns any exception instead of throwing.\r\n */\r\nfunction disposeSingle(\r\n\tdisposable:IDisposable,\r\n\ttrapExceptions:boolean):any\r\n{\r\n\tif(disposable && Type.of(disposable).member('dispose').isFunction)\r\n\t{\r\n\t\tif(trapExceptions)\r\n\t\t{\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tdisposable.dispose();\r\n\t\t\t}\r\n\t\t\tcatch(ex)\r\n\t\t\t{\r\n\t\t\t\treturn ex;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t\tdisposable.dispose();\r\n\t}\r\n\r\n\treturn null;\r\n}\r\n\r\n/**\r\n * This dispose method assumes it's working on a local copy and is unsafe for external use.\r\n */\r\nfunction disposeTheseInternal(\r\n\tdisposables:IDisposable[],\r\n\ttrapExceptions:boolean,\r\n\tindex:number = 0):any[]\r\n{\r\n\tvar exceptions:any[];\r\n\tvar len = disposables.length;\r\n\r\n\tfor(; index<len; index++)\r\n\t{\r\n\t\tvar next = disposables[index];\r\n\t\tif(!next) continue;\r\n\t\tif(trapExceptions)\r\n\t\t{\r\n\t\t\tvar ex = disposeSingle(next, true);\r\n\t\t\tif(ex)\r\n\t\t\t{\r\n\t\t\t\tif(!exceptions) exceptions = [];\r\n\t\t\t\texceptions.push(ex);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tvar success = false;\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tdisposeSingle(next, false);\r\n\t\t\t\tsuccess = true;\r\n\t\t\t}\r\n\t\t\t\t// Don't trap the exception in order to allow it to propagate the stack trace.\r\n\t\t\tfinally\r\n\t\t\t{\r\n\t\t\t\tif(!success && index + 1<len)\r\n\t\t\t\t{\r\n\t\t\t\t\t/* If code is 'continued' by the debugger,\r\n\t\t\t\t\t * need to ensure the rest of the disposables are cared for. */\r\n\t\t\t\t\tdisposeTheseInternal(disposables, false, index + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Just in case...  Should never happen, but asserts the intention.\r\n\t\t\tif(!success) break;\r\n\t\t}\r\n\t}\r\n\r\n\treturn exceptions;\r\n}\r\n\r\nexport default dispose;"]}