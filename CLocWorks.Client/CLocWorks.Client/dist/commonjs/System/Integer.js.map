{"version":3,"sources":["System/Integer.js","System/Integer.ts"],"names":[],"mappings":"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","file":"System/Integer.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst ArgumentException_1 = require(\"./Exceptions/ArgumentException\");\nconst ArgumentOutOfRangeException_1 = require(\"./Exceptions/ArgumentOutOfRangeException\");\nfunction Integer(n) {\n    return Math.floor(n);\n}\nexports.Integer = Integer;\nvar Integer;\n(function (Integer) {\n    Integer.MAX_32_BIT = 2147483647;\n    function r(maxExclusive) {\n        return (Math.random() * maxExclusive) | 0;\n    }\n    function random(maxExclusive) {\n        assert(maxExclusive, 'maxExclusive');\n        return r(maxExclusive);\n    }\n    Integer.random = random;\n    var random;\n    (function (random) {\n        function next(boundary, inclusive) {\n            assert(boundary, 'max');\n            if (boundary === 0)\n                return 0;\n            if (inclusive)\n                boundary += boundary / Math.abs(boundary);\n            return r(boundary);\n        }\n        random.next = next;\n        function nextInRange(min, max, inclusive) {\n            assert(min, 'min');\n            assert(max, 'max');\n            var range = max - min;\n            if (range === 0)\n                return min;\n            if (inclusive)\n                range += range / Math.abs(range);\n            return min + next(range);\n        }\n        random.nextInRange = nextInRange;\n        function select(source) {\n            return source && source.length\n                ? source[r(source.length)]\n                : void (0);\n        }\n        random.select = select;\n        var select;\n        (function (select) {\n            function one(source) {\n                return random.select(source);\n            }\n            select.one = one;\n        })(select = random.select || (random.select = {}));\n    })(random = Integer.random || (Integer.random = {}));\n    function as32Bit(n) {\n        var result = n | 0;\n        return (n === -1 || result !== -1) ? result : null;\n    }\n    Integer.as32Bit = as32Bit;\n    const NUMBER = \"number\";\n    function is(n) {\n        return typeof n === NUMBER && isFinite(n) && n === Math.floor(n);\n    }\n    Integer.is = is;\n    function is32Bit(n) {\n        return n === (n | 0);\n    }\n    Integer.is32Bit = is32Bit;\n    function assert(n, argumentName) {\n        var i = is(n);\n        if (!i)\n            throw new ArgumentException_1.ArgumentException(argumentName || 'n', \"Must be a integer.\");\n        return i;\n    }\n    Integer.assert = assert;\n    function assertZeroOrGreater(n, argumentName) {\n        var i = assert(n, argumentName) && n >= 0;\n        if (!i)\n            throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(argumentName || 'n', n, \"Must be a valid integer greater than or equal to zero.\");\n        return i;\n    }\n    Integer.assertZeroOrGreater = assertZeroOrGreater;\n    function assertPositive(n, argumentName) {\n        var i = assert(n, argumentName) && n > 0;\n        if (!i)\n            throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(argumentName || 'n', n, \"Must be greater than zero.\");\n        return i;\n    }\n    Integer.assertPositive = assertPositive;\n})(Integer = exports.Integer || (exports.Integer = {}));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Integer;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {ArgumentException} from \"./Exceptions/ArgumentException\";\r\nimport {ArgumentOutOfRangeException} from \"./Exceptions/ArgumentOutOfRangeException\";\r\nimport {IArray} from \"./Collections/Array/IArray\";\r\n\r\nexport function Integer(n:number):number\r\n{\r\n\treturn Math.floor(n);\r\n}\r\n\r\nexport module Integer\r\n{\r\n\texport const MAX_32_BIT:number = 2147483647;\r\n\r\n\tfunction r(maxExclusive:number):number\r\n\t{\r\n\t\treturn (Math.random()*maxExclusive) | 0;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns a random integer from minInclusive to the maxExclusive.\r\n\t * Negative numbers are allowed.\r\n\t *\r\n\t * @param maxExclusive\r\n\t * @returns {number}\r\n\t */\r\n\texport function random(maxExclusive:number):number\r\n\t{\r\n\t\tassert(maxExclusive, 'maxExclusive');\r\n\t\treturn r(maxExclusive);\r\n\t}\r\n\r\n\texport module random\r\n\t{\r\n\t\texport function next(\r\n\t\t\tboundary:number,\r\n\t\t\tinclusive?:boolean):number\r\n\t\t{\r\n\t\t\tassert(boundary, 'max');\r\n\t\t\tif(boundary===0) return 0;\r\n\t\t\tif(inclusive) boundary += boundary/Math.abs(boundary);\r\n\t\t\treturn r(boundary);\r\n\t\t}\r\n\r\n\t\texport function nextInRange(\r\n\t\t\tmin:number,\r\n\t\t\tmax:number,\r\n\t\t\tinclusive?:boolean):number\r\n\t\t{\r\n\t\t\tassert(min, 'min');\r\n\t\t\tassert(max, 'max');\r\n\t\t\tvar range = max - min;\r\n\t\t\tif(range===0) return min;\r\n\t\t\tif(inclusive) range += range/Math.abs(range);\r\n\t\t\treturn min + next(range);\r\n\t\t}\r\n\r\n\t\texport function select<T>(source:IArray<T>):T\r\n\t\t{\r\n\t\t\treturn source && source.length\r\n\t\t\t\t? source[r(source.length)]\r\n\t\t\t\t: void(0);\r\n\t\t}\r\n\r\n\t\texport module select\r\n\t\t{\r\n\t\t\texport function one<T>(source:IArray<T>):T\r\n\t\t\t{\r\n\t\t\t\treturn random.select(source);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\texport function as32Bit(n:number):number\r\n\t{\r\n\t\tvar result = n | 0;\r\n\t\treturn (n=== -1 || result!== -1) ? result : null;\r\n\t}\r\n\r\n\tconst NUMBER:string = \"number\";\r\n\r\n\texport function is(n:number):boolean\r\n\t{\r\n\t\treturn typeof n===NUMBER && isFinite(n) && n===Math.floor(n);\r\n\t}\r\n\r\n\texport function is32Bit(n:number):boolean\r\n\t{\r\n\t\treturn n===(n | 0);\r\n\t}\r\n\r\n\r\n\texport function assert(n:number, argumentName?:string):boolean\r\n\t{\r\n\t\tvar i = is(n);\r\n\t\tif(!i)\r\n\t\t\tthrow new ArgumentException(argumentName || 'n', \"Must be a integer.\");\r\n\t\treturn i;\r\n\t}\r\n\r\n\texport function assertZeroOrGreater(n:number, argumentName?:string):boolean\r\n\t{\r\n\t\tvar i = assert(n, argumentName) && n>=0;\r\n\t\tif(!i)\r\n\t\t\tthrow new ArgumentOutOfRangeException(argumentName || 'n', n, \"Must be a valid integer greater than or equal to zero.\");\r\n\t\treturn i;\r\n\t}\r\n\r\n\texport function assertPositive(n:number, argumentName?:string):boolean\r\n\t{\r\n\t\tvar i = assert(n, argumentName) && n>0;\r\n\t\tif(!i)\r\n\t\t\tthrow new ArgumentOutOfRangeException(argumentName || 'n', n, \"Must be greater than zero.\");\r\n\t\treturn i;\r\n\t}\r\n\r\n}\r\n\r\nexport default Integer;\r\n"]}