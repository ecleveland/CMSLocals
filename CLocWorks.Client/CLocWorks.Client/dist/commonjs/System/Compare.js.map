{"version":3,"sources":["System/Compare.js","System/Compare.ts"],"names":[],"mappings":"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","file":"System/Compare.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst Types_1 = require(\"./Types\");\nvar isTrueNaN = Types_1.Type.isTrueNaN;\nconst VOID0 = void 0;\nfunction areEqual(a, b, strict = true) {\n    return a === b\n        || !strict && a == b\n        || isTrueNaN(a) && isTrueNaN(b);\n}\nexports.areEqual = areEqual;\nconst COMPARE_TO = \"compareTo\";\nfunction compare(a, b, strict = true) {\n    if (areEqual(a, b, strict))\n        return 0;\n    if (a && Types_1.Type.hasMember(a, COMPARE_TO))\n        return a.compareTo(b);\n    else if (b && Types_1.Type.hasMember(b, COMPARE_TO))\n        return -b.compareTo(a);\n    if (a > b || strict && (a === 0 && b == 0 || a === null && b === VOID0))\n        return 1;\n    if (b > a || strict && (b === 0 && a == 0 || b === null && a === VOID0))\n        return -1;\n    return NaN;\n}\nexports.compare = compare;\nfunction areEquivalent(a, b, nullEquivalency = true, extraDepth = 0) {\n    if (areEqual(a, b, true))\n        return true;\n    if (a === null || a === VOID0 || b == null || b === VOID0) {\n        if (!nullEquivalency)\n            return false;\n        if (Types_1.Type.isObject(a)) {\n            return !Object.keys(a).length;\n        }\n        if (Types_1.Type.isObject(b)) {\n            return !Object.keys(b).length;\n        }\n        return (a === null || a === VOID0) && (b == null || b === VOID0);\n    }\n    if (Types_1.Type.isObject(a) && Types_1.Type.isObject(b)) {\n        var aKeys = Object.keys(a), bKeys = Object.keys(b), len = aKeys.length;\n        if (len != bKeys.length)\n            return false;\n        aKeys.sort();\n        bKeys.sort();\n        for (let i = 0; i < len; i++) {\n            let key = aKeys[i];\n            if (key !== bKeys[i] || !areEqual(a[key], b[key], true))\n                return false;\n        }\n        if (extraDepth > 0) {\n            for (let key of aKeys) {\n                if (!areEquivalent(a[key], b[key], nullEquivalency, extraDepth - 1))\n                    return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nexports.areEquivalent = areEquivalent;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n\r\nimport {Type} from \"./Types\";\r\nimport {Primitive} from \"./Primitive\";\r\nimport {IComparable} from \"./IComparable\";\r\nimport {CompareResult} from \"./CompareResult\";\r\nimport isTrueNaN = Type.isTrueNaN;\r\n\r\nconst VOID0:any = void 0;\r\n\r\n/**\r\n * Used for special comparison including NaN.\r\n * @param a\r\n * @param b\r\n * @param strict\r\n * @returns {boolean|any}\r\n */\r\nexport function areEqual(a:any, b:any, strict:boolean = true):boolean\r\n{\r\n\treturn a===b\r\n\t\t|| !strict && a==b\r\n\t\t|| isTrueNaN(a) && isTrueNaN(b);\r\n}\r\n\r\nconst COMPARE_TO = \"compareTo\";\r\n\r\n/**\r\n * Compares two comparable objects or primitives.\r\n * @param a\r\n * @param b\r\n */\r\nexport function compare<T>(a:IComparable<T>, b:IComparable<T>):number;\r\nexport function compare<T extends Primitive>(a:T, b:T, strict?:boolean):CompareResult;\r\nexport function compare(a:any, b:any, strict:boolean = true):CompareResult\r\n{\r\n\r\n\tif(areEqual(a, b, strict))\r\n\t\treturn CompareResult.Equal;\r\n\r\n\tif(a && Type.hasMember(a, COMPARE_TO))\r\n\t\treturn a.compareTo(b); // If a has compareTo, use it.\r\n\telse if(b && Type.hasMember(b, COMPARE_TO))\r\n\t\treturn -b.compareTo(a); // a doesn't have compareTo? check if b does and invert.\r\n\r\n\t// Allow for special inequality..\r\n\r\n\tif(a>b || strict && (a===0 && b==0 || a===null && b===VOID0))\r\n\t\treturn CompareResult.Greater;\r\n\r\n\tif(b>a || strict && (b===0 && a==0 || b===null && a===VOID0))\r\n\t\treturn CompareResult.Less;\r\n\r\n\treturn NaN;\r\n}\r\n\r\n/**\r\n * Determines if two primitives are equal or if two objects have the same key/value combinations.\r\n * @param a\r\n * @param b\r\n * @param nullEquivalency If true, null/undefined will be equivalent to an empty object {}.\r\n * @param extraDepth\r\n * @returns {boolean}\r\n */\r\nexport function areEquivalent(a:any, b:any, nullEquivalency:boolean = true, extraDepth:number = 0):boolean\r\n{\r\n\r\n\t// Take a step by step approach to ensure efficiency.\r\n\tif(areEqual(a, b, true)) return true;\r\n\r\n\tif(a===null || a===VOID0 || b==null || b===VOID0)\r\n\t{\r\n\t\tif(!nullEquivalency) return false;\r\n\r\n\t\tif(Type.isObject(a))\r\n\t\t{\r\n\t\t\treturn !Object.keys(a).length;\r\n\t\t}\r\n\r\n\t\tif(Type.isObject(b))\r\n\t\t{\r\n\t\t\treturn !Object.keys(b).length;\r\n\t\t}\r\n\r\n\t\treturn (a===null || a===VOID0) && (b==null || b===VOID0);\r\n\t}\r\n\r\n\tif(Type.isObject(a) && Type.isObject(b))\r\n\t{\r\n\r\n\t\tvar aKeys = Object.keys(a), bKeys = Object.keys(b), len = aKeys.length;\r\n\t\tif(len!=bKeys.length)\r\n\t\t\treturn false;\r\n\r\n\t\taKeys.sort();\r\n\t\tbKeys.sort();\r\n\r\n\t\tfor(let i = 0; i<len; i++)\r\n\t\t{\r\n\t\t\tlet key = aKeys[i];\r\n\t\t\tif(key!==bKeys[i] || !areEqual(a[key], b[key], true)) return false;\r\n\t\t}\r\n\r\n\t\t// Doesn't track circular references but allows for controlling the amount of recursion.\r\n\t\tif(extraDepth>0) {\r\n\r\n\t\t\tfor(let key of aKeys) {\r\n\t\t\t\tif(!areEquivalent(a[key], b[key], nullEquivalency, extraDepth-1)) return false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n"]}