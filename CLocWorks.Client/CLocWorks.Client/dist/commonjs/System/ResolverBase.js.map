{"version":3,"sources":["System/ResolverBase.js","System/ResolverBase.ts"],"names":[],"mappings":";;;;AAIA;;;;;;;;;;ACCA,IAAA,mBAAA,QAA6B,6BAA7B,CAAA;AAEA,IAAA,0BAAA,QAAoC,oCAApC,CAAA;;IAQA;;;AAMC,aAND,YAMC,CACW,aADX,EAES,eAFT,EAGS,WAHT,EAG6B;8BAT9B,cAS8B;;2EAT9B,0BAS8B;;AAFlB,cAAA,aAAA,GAAA,aAAA,CAEkB;AADpB,cAAA,eAAA,GAAA,eAAA,CACoB;AAApB,cAAA,WAAA,GAAA,WAAA,CAAoB;AAG5B,YAAG,CAAC,aAAD,EAAgB,MAAM,IAAI,wBAAA,qBAAA,CAAsB,cAA1B,CAAN,CAAnB;AACA,cAAK,eAAL,GAAuB,KAAvB,CAJ4B;;KAH7B;;iBAND;;mCAkBmB;AAEjB,mBAAO,KAAK,MAAL,CAFU;;;;mCAUV;AAGP,gBAAI,IAAI,IAAJ,CAHG;AAKP,cAAE,eAAF,GALO;AAOP,gBAAG,EAAE,eAAF,KAAoB,IAApB,EACF,MAAM,IAAI,KAAJ,CAAU,qBAAV,CAAN,CADD;AAGA,gBAAG,CAAC,EAAE,eAAF,IAAqB,EAAE,aAAF,EACzB;AACC,kBAAE,eAAF,GAAoB,IAApB,CADD;AAEC,oBACA;AACC,wBAAI,aAAJ,CADD;AAEC,wBAAG,CAAC,EAAE,eAAF,KAAsB,IAAI,EAAE,aAAF,CAA3B,EACH;AACC,0BAAE,eAAF,GAAoB,IAApB,CADD;AAEC,4BAAG,CAAC,KAAK,WAAL,EAAkB,KAAK,aAAL,GAAqB,IAArB,CAAtB;AACA,4BAAI,IAAI,GAAJ,CAHL;AAIC,0BAAE,MAAF,GAAW,CAAX,CAJD;AAKC,0BAAE,MAAF,GAAW,KAAK,CAAL,CALZ;AAMC,+BAAO,CAAP,CAND;qBADA;iBAHD,CAaA,OAAM,EAAN,EACA;AACC,sBAAE,MAAF,GAAW,EAAX,CADD;AAEC,wBAAG,CAAC,EAAE,eAAF,EAAmB,MAAM,EAAN,CAAvB;iBAHD,SAMA;AACC,sBAAE,eAAF,GAAoB,IAApB,CADD;iBAnBA;aAHD;AA6BA,mBAAO,EAAE,MAAF,CAvCA;;;;qCAgDY;AAEnB,iBAAK,aAAL,GAAqB,IAArB,CAFmB;AAGnB,iBAAK,MAAL,GAAc,IAAd,CAHmB;AAInB,iBAAK,eAAL,GAAuB,IAAvB,CAJmB;;;;mCAOZ;AAEP,gBAAI,IAAI,IAAJ,CAFG;AAIP,gBAAG,CAAC,EAAE,aAAF,EACH,OAAO,KAAP,CADD,KAGA;AACC,kBAAE,eAAF,GAAoB,KAApB,CADD;AAEC,kBAAE,MAAF,GAAW,IAAX,CAFD;AAGC,kBAAE,MAAF,GAAW,KAAK,CAAL,CAHZ;AAIC,uBAAO,IAAP,CAJD;aAHA;;;;4BAhEQ;AAER,mBAAO,KAAK,QAAL,EAAP,CAFQ;;;;4BAgDG;AAEX,mBAAO,KAAK,WAAL,IAAoB,CAAC,CAAC,KAAK,aAAL,CAFlB;;;;WAvEb;EAA8C,iBAAA,cAAA;;AAAxB,QAAA,YAAA,GAAY,YAAZ;AAoGtB,OAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA,EAAA,OAAA,IAAA,EAAA;ADxCA,QAAQ,OAAR,GCwCe,YDxCf","file":"System/ResolverBase.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst DisposableBase_1 = require(\"./Disposable/DisposableBase\");\nconst ArgumentNullException_1 = require(\"./Exceptions/ArgumentNullException\");\nclass ResolverBase extends DisposableBase_1.DisposableBase {\n    constructor(_valueFactory, _trapExceptions, _allowReset) {\n        super();\n        this._valueFactory = _valueFactory;\n        this._trapExceptions = _trapExceptions;\n        this._allowReset = _allowReset;\n        if (!_valueFactory)\n            throw new ArgumentNullException_1.ArgumentNullException(\"valueFactory\");\n        this._isValueCreated = false;\n    }\n    getError() {\n        return this._error;\n    }\n    get error() {\n        return this.getError();\n    }\n    getValue() {\n        var _ = this;\n        _.throwIfDisposed();\n        if (_._isValueCreated === null)\n            throw new Error(\"Recursion detected.\");\n        if (!_._isValueCreated && _._valueFactory) {\n            _._isValueCreated = null;\n            try {\n                let c;\n                if (!_._isValueCreated && (c = _._valueFactory)) {\n                    _._isValueCreated = null;\n                    if (!this._allowReset)\n                        this._valueFactory = null;\n                    var v = c();\n                    _._value = v;\n                    _._error = void 0;\n                    return v;\n                }\n            }\n            catch (ex) {\n                _._error = ex;\n                if (!_._trapExceptions)\n                    throw ex;\n            }\n            finally {\n                _._isValueCreated = true;\n            }\n        }\n        return _._value;\n    }\n    get canReset() {\n        return this._allowReset && !!this._valueFactory;\n    }\n    _onDispose() {\n        this._valueFactory = null;\n        this._value = null;\n        this._isValueCreated = null;\n    }\n    tryReset() {\n        var _ = this;\n        if (!_._valueFactory)\n            return false;\n        else {\n            _._isValueCreated = false;\n            _._value = null;\n            _._error = void 0;\n            return true;\n        }\n    }\n}\nexports.ResolverBase = ResolverBase;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ResolverBase;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {DisposableBase} from \"./Disposable/DisposableBase\";\r\nimport {Func} from \"./FunctionTypes\";\r\nimport {ArgumentNullException} from \"./Exceptions/ArgumentNullException\";\r\n\r\n/**\r\n * The ResolverBase class handles resolving a factory method and detects recursion.\r\n * Since JS does not have a synchronization mechanism (lock or otherwise)\r\n * we have to prevent getValue from double triggering the value factory (optimistic concurrency)\r\n * or returning return a value that is intermediate between resolving and resolved.\r\n */\r\nexport abstract class ResolverBase<T> extends DisposableBase\r\n{\r\n\r\n\tprotected _isValueCreated:boolean;\r\n\tprotected _value:T;\r\n\r\n\tconstructor(\r\n\t\tprotected _valueFactory:Func<T>,\r\n\t\tprivate _trapExceptions:boolean,\r\n\t\tprivate _allowReset?:boolean)\r\n\t{\r\n\t\tsuper();\r\n\t\tif(!_valueFactory) throw new ArgumentNullException(\"valueFactory\");\r\n\t\tthis._isValueCreated = false;\r\n\t}\r\n\r\n\tprotected _error:any;\r\n\r\n\tprotected getError():any\r\n\t{\r\n\t\treturn this._error;\r\n\t}\r\n\r\n\tget error():any\r\n\t{\r\n\t\treturn this.getError();\r\n\t}\r\n\r\n\tgetValue():T\r\n\t{\r\n\r\n\t\tvar _ = this;\r\n\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tif(_._isValueCreated===null)\r\n\t\t\tthrow new Error(\"Recursion detected.\");\r\n\r\n\t\tif(!_._isValueCreated && _._valueFactory)\r\n\t\t{\r\n\t\t\t_._isValueCreated = null; // Mark this as 'resolving'.\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tlet c:Func<T>;\r\n\t\t\t\tif(!_._isValueCreated && (c = _._valueFactory))\r\n\t\t\t\t{\r\n\t\t\t\t\t_._isValueCreated = null; // Mark this as 'resolving'.\r\n\t\t\t\t\tif(!this._allowReset) this._valueFactory = null;\r\n\t\t\t\t\tvar v = c();\r\n\t\t\t\t\t_._value = v;\r\n\t\t\t\t\t_._error = void 0;\r\n\t\t\t\t\treturn v;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcatch(ex)\r\n\t\t\t{\r\n\t\t\t\t_._error = ex;\r\n\t\t\t\tif(!_._trapExceptions) throw ex;\r\n\t\t\t}\r\n\t\t\tfinally\r\n\t\t\t{\r\n\t\t\t\t_._isValueCreated = true;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\treturn _._value;\r\n\r\n\t}\r\n\r\n\tget canReset():boolean\r\n\t{\r\n\t\treturn this._allowReset && !!this._valueFactory;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tthis._valueFactory = null;\r\n\t\tthis._value = null;\r\n\t\tthis._isValueCreated = null;\r\n\t}\r\n\r\n\ttryReset():boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\r\n\t\tif(!_._valueFactory)\r\n\t\t\treturn false;\r\n\t\telse\r\n\t\t{\r\n\t\t\t_._isValueCreated = false;\r\n\t\t\t_._value = null;\r\n\t\t\t_._error = void 0;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\nexport default ResolverBase;"]}