{"version":3,"sources":["System/Uri/Uri.js","System/Uri/Uri.ts"],"names":[],"mappings":"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","file":"System/Uri/Uri.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n * Based on: https://en.wikipedia.org/wiki/Uniform_Resource_Identifier\n */\n\"use strict\";\nconst Types_1 = require(\"../Types\");\nconst QueryParams = require(\"./QueryParams\");\nconst Scheme = require(\"./Scheme\");\nconst Utility_1 = require(\"../Text/Utility\");\nconst ArgumentException_1 = require(\"../Exceptions/ArgumentException\");\nconst ArgumentOutOfRangeException_1 = require(\"../Exceptions/ArgumentOutOfRangeException\");\nconst VOID0 = void (0);\nclass Uri {\n    constructor(scheme, userInfo, host, port, path, query, fragment) {\n        var _ = this;\n        _.scheme = getScheme(scheme) || null;\n        _.userInfo = userInfo || null;\n        _.host = host || null;\n        _.port = getPort(port);\n        _.authority = _.getAuthority() || null;\n        _.path = path || null;\n        if (!Types_1.Type.isString(query))\n            query = QueryParams.encode(query);\n        _.query = formatQuery(query) || null;\n        Object.freeze(_.queryParams\n            = _.query\n                ? QueryParams.parseToMap(_.query)\n                : {});\n        _.pathAndQuery = _.getPathAndQuery() || null;\n        _.fragment = formatFragment(fragment) || null;\n        _.absoluteUri = _.getAbsoluteUri();\n        _.baseUri = _.absoluteUri.replace(/[?#].*/, '');\n        Object.freeze(_);\n    }\n    equals(other) {\n        return this === other || this.absoluteUri == Uri.toString(other);\n    }\n    static from(uri, defaults) {\n        var u = (!uri || Types_1.Type.isString(uri))\n            ? Uri.parse(uri) : uri;\n        return new Uri(u.scheme || defaults && defaults.scheme, u.userInfo || defaults && defaults.userInfo, u.host || defaults && defaults.host, isNaN(u.port) ? defaults && defaults.port : u.port, u.path || defaults && defaults.path, u.query || defaults && defaults.query, u.fragment || defaults && defaults.fragment);\n    }\n    static parse(url, throwIfInvalid = true) {\n        var result = null;\n        var ex = tryParse(url, (out) => { result = out; });\n        if (throwIfInvalid && ex)\n            throw ex;\n        return result;\n    }\n    static tryParse(url, out) {\n        return !tryParse(url, out);\n    }\n    static copyOf(map) {\n        return copyUri(map);\n    }\n    copyTo(map) {\n        return copyUri(this, map);\n    }\n    updateQuery(query) {\n        var map = this.toMap();\n        map.query = query;\n        return Uri.from(map);\n    }\n    getAbsoluteUri() {\n        return uriToString(this);\n    }\n    getAuthority() {\n        return getAuthority(this);\n    }\n    getPathAndQuery() {\n        return getPathAndQuery(this);\n    }\n    get pathSegments() {\n        return this.path.match(/^[/]|[^/]*[/]|[^/]+$/g);\n    }\n    toMap() {\n        return this.copyTo({});\n    }\n    toString() {\n        return this.absoluteUri;\n    }\n    static toString(uri) {\n        return uri instanceof Uri\n            ? uri.absoluteUri\n            : uriToString(uri);\n    }\n    static getAuthority(uri) {\n        return getAuthority(uri);\n    }\n}\nexports.Uri = Uri;\n(function (Fields) {\n    Fields[Fields[\"scheme\"] = 0] = \"scheme\";\n    Fields[Fields[\"userInfo\"] = 1] = \"userInfo\";\n    Fields[Fields[\"host\"] = 2] = \"host\";\n    Fields[Fields[\"port\"] = 3] = \"port\";\n    Fields[Fields[\"path\"] = 4] = \"path\";\n    Fields[Fields[\"query\"] = 5] = \"query\";\n    Fields[Fields[\"fragment\"] = 6] = \"fragment\";\n})(exports.Fields || (exports.Fields = {}));\nvar Fields = exports.Fields;\nObject.freeze(Fields);\nfunction copyUri(from, to) {\n    var i = 0, field;\n    if (!to)\n        to = {};\n    while (field = Fields[i++]) {\n        var value = from[field];\n        if (value)\n            to[field] = value;\n    }\n    return to;\n}\nconst SLASH = '/', SLASH2 = '//', QM = QueryParams.Separator.Query, HASH = '#', EMPTY = '', AT = '@';\nfunction getScheme(scheme) {\n    var s = scheme;\n    if (Types_1.Type.isString(s)) {\n        if (!s)\n            return null;\n        s = Utility_1.trim(s).toLowerCase().replace(/[^a-z0-9+.-]+$/g, EMPTY);\n        if (!s)\n            return null;\n        if (Scheme.isValid(s))\n            return s;\n    }\n    else {\n        if (s === null || s === undefined)\n            return s;\n    }\n    throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException('scheme', scheme, 'Invalid scheme.');\n}\nfunction getPort(port) {\n    if (port === 0)\n        return port;\n    if (!port)\n        return null;\n    var p;\n    if (Types_1.Type.isNumber(port, true)) {\n        p = port;\n        if (p >= 0 && isFinite(p))\n            return p;\n    }\n    else if (Types_1.Type.isString(port) && (p = parseInt(port)) && !isNaN(p)) {\n        return getPort(p);\n    }\n    throw new ArgumentException_1.ArgumentException(\"port\", \"invalid value\");\n}\nfunction getAuthority(uri) {\n    if (!uri.host) {\n        if (uri.userInfo)\n            throw new ArgumentException_1.ArgumentException('host', 'Cannot include user info when there is no host.');\n        if (Types_1.Type.isNumber(uri.port, false))\n            throw new ArgumentException_1.ArgumentException('host', 'Cannot include a port when there is no host.');\n    }\n    var result = uri.host || EMPTY;\n    if (result) {\n        if (uri.userInfo)\n            result = uri.userInfo + AT + result;\n        if (!isNaN(uri.port))\n            result += ':' + uri.port;\n        result = SLASH2 + result;\n    }\n    return result;\n}\nfunction formatQuery(query) {\n    return query && ((query.indexOf(QM) !== 0 ? QM : EMPTY) + query);\n}\nfunction formatFragment(fragment) {\n    return fragment && ((fragment.indexOf(HASH) !== 0 ? HASH : EMPTY) + fragment);\n}\nfunction getPathAndQuery(uri) {\n    var path = uri.path, query = uri.query;\n    return EMPTY\n        + (path || EMPTY)\n        + (formatQuery(query) || EMPTY);\n}\nfunction uriToString(uri) {\n    var scheme = getScheme(uri.scheme), authority = getAuthority(uri), pathAndQuery = getPathAndQuery(uri), fragment = formatFragment(uri.fragment);\n    var part1 = EMPTY\n        + ((scheme && (scheme + ':')) || EMPTY)\n        + (authority || EMPTY);\n    var part2 = EMPTY\n        + (pathAndQuery || EMPTY)\n        + (fragment || EMPTY);\n    if (part1 && part2 && scheme && !authority)\n        throw new ArgumentException_1.ArgumentException('authority', \"Cannot format schemed Uri with missing authority.\");\n    if (part1 && pathAndQuery && pathAndQuery.indexOf(SLASH) !== 0)\n        part2 = SLASH + part2;\n    return part1 + part2;\n}\nfunction tryParse(url, out) {\n    if (!url)\n        return new ArgumentException_1.ArgumentException('url', 'Nothing to parse.');\n    var i, result = {};\n    i = url.indexOf(HASH);\n    if (i != -1) {\n        result.fragment = url.substring(i + 1) || VOID0;\n        url = url.substring(0, i);\n    }\n    i = url.indexOf(QM);\n    if (i != -1) {\n        result.query = url.substring(i + 1) || VOID0;\n        url = url.substring(0, i);\n    }\n    i = url.indexOf(SLASH2);\n    if (i != -1) {\n        var scheme = Utility_1.trim(url.substring(0, i)), c = /:$/;\n        if (!c.test(scheme))\n            return new ArgumentException_1.ArgumentException('url', 'Scheme was improperly formatted');\n        scheme = Utility_1.trim(scheme.replace(c, EMPTY));\n        try {\n            result.scheme = getScheme(scheme) || VOID0;\n        }\n        catch (ex) {\n            return ex;\n        }\n        url = url.substring(i + 2);\n    }\n    i = url.indexOf(SLASH);\n    if (i != -1) {\n        result.path = url.substring(i);\n        url = url.substring(0, i);\n    }\n    i = url.indexOf(AT);\n    if (i != -1) {\n        result.userInfo = url.substring(0, i) || VOID0;\n        url = url.substring(i + 1);\n    }\n    i = url.indexOf(':');\n    if (i != -1) {\n        var port = parseInt(Utility_1.trim(url.substring(i + 1)));\n        if (isNaN(port))\n            return new ArgumentException_1.ArgumentException('url', 'Port was invalid.');\n        result.port = port;\n        url = url.substring(0, i);\n    }\n    url = Utility_1.trim(url);\n    if (url)\n        result.host = url;\n    out(copyUri(result));\n    return null;\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Uri;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Based on: https://en.wikipedia.org/wiki/Uniform_Resource_Identifier\r\n */\r\n\r\n\r\nimport {Type} from \"../Types\";\r\nimport * as QueryParams from \"./QueryParams\";\r\nimport * as QueryParam from \"./QueryParam\";\r\nimport * as UriComponent from \"./UriComponent\";\r\nimport * as Scheme from \"./Scheme\";\r\nimport {SchemeValue} from \"./SchemeValue\";\r\nimport {trim} from \"../Text/Utility\";\r\nimport {Exception} from \"../Exception\";\r\nimport {ArgumentException} from \"../Exceptions/ArgumentException\";\r\nimport {ArgumentOutOfRangeException} from \"../Exceptions/ArgumentOutOfRangeException\";\r\nimport {IUri} from \"./IUri\";\r\nimport {IMap} from \"../Collections/Dictionaries/IDictionary\";\r\nimport {Primitive} from \"../Primitive\";\r\nimport {StringKeyValuePair} from \"../KeyValuePair\";\r\nimport {IEquatable} from \"../IEquatable\";\r\n\r\nconst VOID0:any = void(0);\r\n\r\n/**\r\n * Provides an read-only model representation of a uniform resource identifier (URI) and easy access to the parts of the URI.\r\n *\r\n * The read-only model (frozen) is easier for debugging than exposing accessors for each property.\r\n * ICloneable&lt;Uri&gt; is not used to prevent unnecessary copying of values that won't change.\r\n */\r\nexport class Uri implements IUri, IEquatable<IUri>\r\n{\r\n\r\n\tscheme:SchemeValue;\r\n\tuserInfo:string;\r\n\thost:string;\r\n\tport:number;\r\n\tpath:string;\r\n\tquery:string;\r\n\tfragment:string;\r\n\r\n\tqueryParams:IMap<Primitive|Primitive[]>;\r\n\r\n\t/**\r\n\t * @param scheme The user name, password, or other user-specific information associated with the specified URI.\r\n\t * @param userInfo The host component of this instance.\r\n\t * @param host The port number of this URI.\r\n\t * @param port The absolute path of the URI.\r\n\t * @param path The absolute path of the URI.\r\n\t * @param query Any query information included in the specified URI.\r\n\t * @param fragment The escaped URI fragment.\r\n\t */\r\n\tconstructor(\r\n\t\tscheme:SchemeValue,\r\n\t\tuserInfo:string,\r\n\t\thost:string,\r\n\t\tport:number,\r\n\t\tpath:string,\r\n\t\tquery?:QueryParam.Convertible,\r\n\t\tfragment?:string)\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.scheme = getScheme(scheme) || null;\r\n\t\t_.userInfo = userInfo || null;\r\n\t\t_.host = host || null;\r\n\r\n\t\t_.port = getPort(port);\r\n\r\n\t\t_.authority = _.getAuthority() || null;\r\n\r\n\t\t_.path = path || null;\r\n\r\n\r\n\t\tif(!Type.isString(query))\r\n\t\t\tquery = QueryParams.encode(<UriComponent.Map|StringKeyValuePair<Primitive>[]>query);\r\n\r\n\t\t_.query = formatQuery(<string>query) || null;\r\n\t\tObject.freeze(_.queryParams\r\n\t\t\t= _.query\r\n\t\t\t? QueryParams.parseToMap(_.query)\r\n\t\t\t: {});\r\n\r\n\t\t_.pathAndQuery = _.getPathAndQuery() || null;\r\n\r\n\t\t_.fragment = formatFragment(fragment) || null;\r\n\r\n\t\t// This should validate the uri...\r\n\t\t_.absoluteUri = _.getAbsoluteUri();\r\n\r\n\t\t_.baseUri = _.absoluteUri.replace(/[?#].*/, '');\r\n\r\n\t\t// Intended to be read-only.  Call .toMap() to get a writable copy.\r\n\t\tObject.freeze(_);\r\n\t}\r\n\r\n\t/**\r\n\t *  Compares the values of another IUri via toString comparison.\r\n\t * @param other\r\n\t * @returns {boolean}\r\n\t */\r\n\tequals(other:IUri):boolean\r\n\t{\r\n\t\treturn this===other || this.absoluteUri==Uri.toString(other);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Parses or clones values from existing Uri values.\r\n\t * @param uri\r\n\t * @param defaults\r\n\t * @returns {Uri}\r\n\t */\r\n\tstatic from(uri:string|IUri, defaults?:IUri):Uri\r\n\t{\r\n\t\tvar u = (!uri || Type.isString(uri))\r\n\t\t\t? Uri.parse(<string>uri) : <IUri>uri;\r\n\r\n\t\treturn new Uri(\r\n\t\t\tu.scheme || defaults && defaults.scheme,\r\n\t\t\tu.userInfo || defaults && defaults.userInfo,\r\n\t\t\tu.host || defaults && defaults.host,\r\n\t\t\tisNaN(u.port) ? defaults && defaults.port : u.port,\r\n\t\t\tu.path || defaults && defaults.path,\r\n\t\t\tu.query || defaults && defaults.query,\r\n\t\t\tu.fragment || defaults && defaults.fragment\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Parses a URL into it's components.\r\n\t * @param url The url to parse.\r\n\t * @param throwIfInvalid Defaults to true.\r\n\t * @returns {IUri} Returns a map of the values or *null* if invalid and *throwIfInvalid* is <b>false</b>.\r\n\t */\r\n\tstatic parse(url:string, throwIfInvalid:boolean = true):IUri\r\n\t{\r\n\t\tvar result:IUri = null;\r\n\t\tvar ex = tryParse(url, (out)=> {result = out;});\r\n\t\tif(throwIfInvalid && ex) throw ex;\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Parses a URL into it's components.\r\n\t * @param url The url to parse.\r\n\t * @param out A delegate to capture the value.\r\n\t * @returns {boolean} True if valid.  False if invalid.\r\n\t */\r\n\tstatic tryParse(url:string, out:(result:IUri)=>void):boolean\r\n\t{\r\n\t\treturn !tryParse(url, out); // return type is Exception.\r\n\t}\r\n\r\n\tstatic copyOf(map:IUri):IUri\r\n\t{\r\n\t\treturn copyUri(map);\r\n\t}\r\n\r\n\tcopyTo(map:IUri):IUri\r\n\t{\r\n\t\treturn copyUri(this, map);\r\n\t}\r\n\r\n\tupdateQuery(query:QueryParam.Convertible):Uri\r\n\t{\r\n\t\tvar map = this.toMap();\r\n\t\tmap.query = <any>query;\r\n\t\treturn Uri.from(map);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Is provided for sub classes to override this value.\r\n\t */\r\n\tprotected getAbsoluteUri():string\r\n\t{\r\n\t\treturn uriToString(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Is provided for sub classes to override this value.\r\n\t */\r\n\tprotected getAuthority():string\r\n\t{\r\n\t\treturn getAuthority(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Is provided for sub classes to override this value.\r\n\t */\r\n\tprotected getPathAndQuery():string\r\n\t{\r\n\t\treturn getPathAndQuery(this);\r\n\t}\r\n\r\n\t/**\r\n\t * The absolute URI.\r\n\t */\r\n\tabsoluteUri:string;\r\n\r\n\t/**\r\n\t * Gets the Domain Name System (DNS) host name or IP address and the port number for a server.\r\n\t */\r\n\tauthority:string;\r\n\r\n\t/**\r\n\t * Gets the path and Query properties separated by a question mark (?).\r\n\t */\r\n\tpathAndQuery:string;\r\n\r\n\t/**\r\n\t * Gets the full path without the query or fragment.\r\n\t */\r\n\tbaseUri:string;\r\n\r\n\t/**\r\n\t * The segments that represent a path.<br/>\r\n\t * https://msdn.microsoft.com/en-us/library/system.uri.segments%28v=vs.110%29.aspx\r\n\t *\r\n\t * <h5><b>Example:</b></h5>\r\n\t * If the path value equals: ```/tree/node/index.html```<br/>\r\n\t * The result will be: ```['/','tree/','node/','index.html']```\r\n\t * @returns {string[]}\r\n\t */\r\n\tget pathSegments():string[]\r\n\t{\r\n\t\treturn this.path.match(/^[/]|[^/]*[/]|[^/]+$/g);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a writable copy.\r\n\t * @returns {IUri}\r\n\t */\r\n\ttoMap():IUri\r\n\t{\r\n\t\treturn this.copyTo({});\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {string} The full absolute uri.\r\n\t */\r\n\ttoString():string\r\n\t{\r\n\t\treturn this.absoluteUri;\r\n\t}\r\n\r\n\t/**\r\n\t * Properly converts an existing URI to a string.\r\n\t * @param uri\r\n\t * @returns {string}\r\n\t */\r\n\tstatic toString(uri:IUri):string\r\n\t{\r\n\t\treturn uri instanceof Uri\r\n\t\t\t? (<Uri>uri).absoluteUri\r\n\t\t\t: uriToString(uri);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the authority segment of an URI.\r\n\t * @param uri\r\n\t * @returns {string}\r\n\t */\r\n\tstatic getAuthority(uri:IUri):string\r\n\t{\r\n\t\treturn getAuthority(uri);\r\n\t}\r\n\r\n\r\n}\r\n\r\nexport enum Fields {\r\n\tscheme,\r\n\tuserInfo,\r\n\thost,\r\n\tport,\r\n\tpath,\r\n\tquery,\r\n\tfragment\r\n}\r\nObject.freeze(Fields);\r\n\r\nfunction copyUri(from:IUri, to?:IUri)\r\n{\r\n\tvar i = 0, field:string;\r\n\tif(!to) to = {};\r\n\twhile(field = Fields[i++])\r\n\t{\r\n\t\tvar value = (<any>from)[field];\r\n\t\tif(value) (<any>to)[field] = value;\r\n\t}\r\n\treturn to;\r\n}\r\n\r\nconst SLASH = '/', SLASH2 = '//', QM = QueryParams.Separator.Query, HASH = '#', EMPTY = '', AT = '@';\r\n\r\nfunction getScheme(scheme:string):SchemeValue\r\n{\r\n\tvar s:any = scheme;\r\n\tif(Type.isString(s))\r\n\t{\r\n\t\tif(!s) return null;\r\n\t\ts = trim(s).toLowerCase().replace(/[^a-z0-9+.-]+$/g, EMPTY);\r\n\t\tif(!s) return null;\r\n\t\tif(Scheme.isValid(s)) return s;\r\n\t} else {\r\n\t\tif(s===null || s===undefined) return s;\r\n\t}\r\n\tthrow new ArgumentOutOfRangeException('scheme', scheme, 'Invalid scheme.');\r\n}\r\n\r\nfunction getPort(port:number|string):number\r\n{\r\n\tif(port===0) return <number>port;\r\n\tif(!port) return null;\r\n\tvar p:number;\r\n\r\n\tif(Type.isNumber(port, true))\r\n\t{\r\n\t\tp = <number>port;\r\n\t\tif(p>=0 && isFinite(p))\r\n\t\t\treturn p;\r\n\t}\r\n\telse if(Type.isString(port) && (p = parseInt(<string>port)) && !isNaN(p))\r\n\t{\r\n\t\treturn getPort(p);\r\n\t}\r\n\r\n\tthrow new ArgumentException(\"port\", \"invalid value\");\r\n}\r\n\r\nfunction getAuthority(uri:IUri):string\r\n{\r\n\r\n\tif(!uri.host)\r\n\t{\r\n\t\tif(uri.userInfo)\r\n\t\t\tthrow new ArgumentException('host', 'Cannot include user info when there is no host.');\r\n\r\n\t\tif(Type.isNumber(uri.port, false))\r\n\t\t\tthrow new ArgumentException('host', 'Cannot include a port when there is no host.');\r\n\t}\r\n\r\n\t/*\r\n\t * [//[user:password@]host[:port]]\r\n\t */\r\n\r\n\tvar result = uri.host || EMPTY;\r\n\r\n\tif(result)\r\n\t{\r\n\t\tif(uri.userInfo) result = uri.userInfo + AT + result;\r\n\t\tif(!isNaN(uri.port)) result += ':' + uri.port;\r\n\t\tresult = SLASH2 + result;\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nfunction formatQuery(query:string):string\r\n{\r\n\treturn query && ((query.indexOf(QM)!==0 ? QM : EMPTY) + query);\r\n}\r\n\r\nfunction formatFragment(fragment:string):string\r\n{\r\n\treturn fragment && ((fragment.indexOf(HASH)!==0 ? HASH : EMPTY) + fragment);\r\n}\r\n\r\nfunction getPathAndQuery(uri:IUri):string\r\n{\r\n\r\n\tvar path  = uri.path,\r\n\t    query = uri.query;\r\n\r\n\treturn EMPTY\r\n\t\t+ (path || EMPTY)\r\n\t\t+ (formatQuery(query) || EMPTY);\r\n\r\n}\r\n\r\nfunction uriToString(uri:IUri):string\r\n{\r\n\t// scheme:[//[user:password@]domain[:port]][/]path[?query][#fragment]\r\n\t// {scheme}{authority}{path}{query}{fragment}\r\n\r\n\tvar scheme       = getScheme(uri.scheme),\r\n\t    authority    = getAuthority(uri),\r\n\t    pathAndQuery = getPathAndQuery(uri),\r\n\t    fragment     = formatFragment(uri.fragment);\r\n\r\n\tvar part1 = EMPTY\r\n\t\t+ ((scheme && (scheme + ':')) || EMPTY)\r\n\t\t+ (authority || EMPTY);\r\n\r\n\tvar part2 = EMPTY\r\n\t\t+ (pathAndQuery || EMPTY)\r\n\t\t+ (fragment || EMPTY);\r\n\r\n\tif(part1 && part2 && scheme && !authority)\r\n\t\tthrow new ArgumentException('authority', \"Cannot format schemed Uri with missing authority.\");\r\n\r\n\tif(part1 && pathAndQuery && pathAndQuery.indexOf(SLASH)!==0)\r\n\t\tpart2 = SLASH + part2;\r\n\r\n\treturn part1 + part2;\r\n\r\n}\r\n\r\n\r\nfunction tryParse(url:string, out:(result:IUri)=>void):Exception\r\n{\r\n\tif(!url)\r\n\t\treturn new ArgumentException('url', 'Nothing to parse.');\r\n\r\n\r\n\t// Could use a regex here, but well follow some rules instead.\r\n\t// The intention is to 'gather' the pieces.  This isn't validation (yet).\r\n\r\n\t// scheme:[//[user:password@]domain[:port]][/]path[?query][#fragment]\r\n\tvar i:number, result:IUri = {};\r\n\r\n\t// Anything after the first # is the fragment.\r\n\ti = url.indexOf(HASH);\r\n\tif(i!= -1)\r\n\t{\r\n\t\tresult.fragment = url.substring(i + 1) || VOID0;\r\n\t\turl = url.substring(0, i);\r\n\t}\r\n\r\n\t// Anything after the first ? is the query.\r\n\ti = url.indexOf(QM);\r\n\tif(i!= -1)\r\n\t{\r\n\t\tresult.query = url.substring(i + 1) || VOID0;\r\n\t\turl = url.substring(0, i);\r\n\t}\r\n\r\n\t// Guarantees a separation.\r\n\ti = url.indexOf(SLASH2);\r\n\tif(i!= -1)\r\n\t{\r\n\t\tvar scheme = trim(url.substring(0, i)), c = /:$/;\r\n\t\tif(!c.test(scheme))\r\n\t\t\treturn new ArgumentException('url', 'Scheme was improperly formatted');\r\n\r\n\t\tscheme = trim(scheme.replace(c, EMPTY));\r\n\t\ttry\r\n\t\t{\r\n\t\t\tresult.scheme = getScheme(scheme) || VOID0;\r\n\t\t}\r\n\t\tcatch(ex)\r\n\t\t{\r\n\t\t\treturn ex;\r\n\t\t}\r\n\r\n\t\turl = url.substring(i + 2);\r\n\t}\r\n\r\n\t// Find any path information.\r\n\ti = url.indexOf(SLASH);\r\n\tif(i!= -1)\r\n\t{\r\n\t\tresult.path = url.substring(i);\r\n\t\turl = url.substring(0, i);\r\n\t}\r\n\r\n\t// Separate user info.\r\n\ti = url.indexOf(AT);\r\n\tif(i!= -1)\r\n\t{\r\n\t\tresult.userInfo = url.substring(0, i) || VOID0;\r\n\t\turl = url.substring(i + 1);\r\n\t}\r\n\r\n\t// Remaining is host and port.\r\n\ti = url.indexOf(':');\r\n\tif(i!= -1)\r\n\t{\r\n\t\tvar port = parseInt(trim(url.substring(i + 1)));\r\n\t\tif(isNaN(port))\r\n\t\t\treturn new ArgumentException('url', 'Port was invalid.');\r\n\r\n\t\tresult.port = port;\r\n\t\turl = url.substring(0, i);\r\n\t}\r\n\r\n\turl = trim(url);\r\n\tif(url)\r\n\t\tresult.host = url;\r\n\r\n\tout(copyUri(result));\r\n\r\n\t// null is good! (here)\r\n\treturn null;\r\n\r\n}\r\n\r\nexport default Uri;"]}