{"version":3,"sources":["System/Uri/QueryParams.js","System/Uri/QueryParams.ts"],"names":[],"mappings":"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","file":"System/Uri/QueryParams.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst Serialization = require(\"../Serialization/Utility\");\nconst Types_1 = require(\"../Types\");\nconst KeyValueExtract_1 = require(\"../KeyValueExtract\");\nconst Enumerator_1 = require(\"../Collections/Enumeration/Enumerator\");\nconst EMPTY = \"\", QUERY_SEPARATOR = \"?\", ENTRY_SEPARATOR = \"&\", KEY_VALUE_SEPARATOR = \"=\", TO_URI_COMPONENT = \"toUriComponent\";\nfunction encode(values, prefixIfNotEmpty) {\n    if (!values)\n        return EMPTY;\n    var entries = [];\n    if (Enumerator_1.isEnumerableOrArrayLike(values)) {\n        Enumerator_1.forEach(values, entry => KeyValueExtract_1.extractKeyValue(entry, (key, value) => appendKeyValue(entries, key, value)));\n    }\n    else {\n        Object.keys(values).forEach(key => appendKeyValue(entries, key, values[key]));\n    }\n    return (entries.length && prefixIfNotEmpty ? QUERY_SEPARATOR : EMPTY)\n        + entries.join(ENTRY_SEPARATOR);\n}\nexports.encode = encode;\nfunction appendKeyValueSingle(entries, key, value) {\n    entries.push(key + KEY_VALUE_SEPARATOR + encodeValue(value));\n}\nfunction appendKeyValue(entries, key, value) {\n    if (Enumerator_1.isEnumerableOrArrayLike(value)) {\n        Enumerator_1.forEach(value, v => appendKeyValueSingle(entries, key, v));\n    }\n    else {\n        appendKeyValueSingle(entries, key, value);\n    }\n}\nfunction encodeValue(value) {\n    var v = null;\n    if (isUriComponentFormattable(value)) {\n        v = value.toUriComponent();\n        if (v && v.indexOf(ENTRY_SEPARATOR) != 1)\n            throw '.toUriComponent() did not encode the value.';\n    }\n    else {\n        v = encodeURIComponent(Serialization.toString(v));\n    }\n    return v;\n}\nexports.encodeValue = encodeValue;\nfunction isUriComponentFormattable(instance) {\n    return Types_1.Type.hasMemberOfType(instance, TO_URI_COMPONENT, Types_1.Type.FUNCTION);\n}\nexports.isUriComponentFormattable = isUriComponentFormattable;\nfunction parse(query, entryHandler, deserialize = true, decodeValues = true) {\n    if (query && (query = query.replace(/^\\s*\\?+/, ''))) {\n        var entries = query.split(ENTRY_SEPARATOR);\n        for (let entry of entries) {\n            var si = entry.indexOf(KEY_VALUE_SEPARATOR);\n            if (si != -1) {\n                var key = entry.substring(0, si);\n                var value = entry.substring(si + 1);\n                if (decodeValues)\n                    value = decodeURIComponent(value);\n                if (deserialize)\n                    value = Serialization.toPrimitive(value);\n                entryHandler(key, value);\n            }\n        }\n    }\n}\nexports.parse = parse;\nfunction parseToMap(query, deserialize = true, decodeValues = true) {\n    var result = {};\n    parse(query, (key, value) => {\n        if ((key) in (result)) {\n            var prev = result[key];\n            if (!(Array.isArray(prev)))\n                result[key] = prev = [prev];\n            prev.push(value);\n        }\n        else\n            result[key] = value;\n    }, deserialize, decodeValues);\n    return result;\n}\nexports.parseToMap = parseToMap;\nfunction parseToArray(query, deserialize = true, decodeValues = true) {\n    var result = [];\n    parse(query, (key, value) => { result.push({ key: key, value: value }); }, deserialize, decodeValues);\n    return result;\n}\nexports.parseToArray = parseToArray;\nvar Separator;\n(function (Separator) {\n    Separator.Query = QUERY_SEPARATOR;\n    Separator.Entry = ENTRY_SEPARATOR;\n    Separator.KeyValue = KEY_VALUE_SEPARATOR;\n})(Separator = exports.Separator || (exports.Separator = {}));\nObject.freeze(Separator);\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n\r\nimport * as Serialization from \"../Serialization/Utility\";\r\nimport * as UriComponent from \"./UriComponent\";\r\nimport * as QueryParam from \"./QueryParam\";\r\nimport {Type} from \"../Types\";\r\nimport {extractKeyValue} from \"../KeyValueExtract\";\r\nimport {forEach, isEnumerableOrArrayLike} from \"../Collections/Enumeration/Enumerator\";\r\nimport {IMap} from \"../Collections/Dictionaries/IDictionary\";\r\nimport {Primitive} from \"../Primitive\";\r\nimport {IStringKeyValuePair} from \"../KeyValuePair\";\r\nimport {IEnumerableOrArray} from \"../Collections/IEnumerableOrArray\";\r\n\r\n/*\r\n * This module is provided as a lighter weight utility for acquiring query params.\r\n * If more detailed operations are necessary, consider importing QueryBuilder.\r\n */\r\n\r\nconst\r\n\tEMPTY               = \"\",\r\n\tQUERY_SEPARATOR     = \"?\",\r\n\tENTRY_SEPARATOR     = \"&\",\r\n\tKEY_VALUE_SEPARATOR = \"=\",\r\n\tTO_URI_COMPONENT    = \"toUriComponent\";\r\n\r\n\r\n/**\r\n * Returns the encoded URI string\r\n * @param values\r\n * @param prefixIfNotEmpty\r\n * @returns {string}\r\n */\r\nexport function encode(\r\n\tvalues:UriComponent.Map | QueryParam.EnumerableOrArray,\r\n\tprefixIfNotEmpty?:boolean):string\r\n{\r\n\tif(!values) return EMPTY;\r\n\tvar entries:string[] = [];\r\n\r\n\tif(isEnumerableOrArrayLike(values))\r\n\t{\r\n\t\tforEach(values, entry=>\r\n\t\t\textractKeyValue(entry,\r\n\t\t\t\t(key, value)=> appendKeyValue(entries, key, value))\r\n\t\t);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tObject.keys(values).forEach(\r\n\t\t\tkey=> appendKeyValue(entries, key, values[key])\r\n\t\t);\r\n\t}\r\n\r\n\treturn (entries.length && prefixIfNotEmpty ? QUERY_SEPARATOR : EMPTY)\r\n\t\t+ entries.join(ENTRY_SEPARATOR);\r\n}\r\n\r\nfunction appendKeyValueSingle(\r\n\tentries:string[],\r\n\tkey:string,\r\n\tvalue:UriComponent.Value):void\r\n{\r\n\tentries.push(key + KEY_VALUE_SEPARATOR + encodeValue(value));\r\n}\r\n\r\n// According to spec, if there is an array of values with the same key, then each value is replicated with that key.\r\nfunction appendKeyValue(\r\n\tentries:string[],\r\n\tkey:string,\r\n\tvalue:UriComponent.Value|IEnumerableOrArray<UriComponent.Value>):void\r\n{\r\n\tif(isEnumerableOrArrayLike(value))\r\n\t{\r\n\t\tforEach(value, v=> appendKeyValueSingle(entries, key, v));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tappendKeyValueSingle(entries, key, value)\r\n\t}\r\n}\r\n\r\n/**\r\n * Converts any primitive, serializable or uri-component object to an encoded string.\r\n * @param value\r\n * @returns {string}\r\n */\r\nexport function encodeValue(value:UriComponent.Value):string\r\n{\r\n\tvar v:string = null;\r\n\tif(isUriComponentFormattable(value))\r\n\t{\r\n\t\tv = value.toUriComponent();\r\n\t\tif(v && v.indexOf(ENTRY_SEPARATOR)!=1)\r\n\t\t\tthrow '.toUriComponent() did not encode the value.';\r\n\t}\r\n\telse\r\n\t{\r\n\t\tv = encodeURIComponent(Serialization.toString(v));\r\n\t}\r\n\treturn v;\r\n}\r\n\r\n/**\r\n * A shortcut for identifying an UriComponent.Formattable object.\r\n * @param instance\r\n * @returns {boolean}\r\n */\r\nexport function isUriComponentFormattable(instance:any):instance is UriComponent.Formattable\r\n{\r\n\treturn Type.hasMemberOfType<UriComponent.Formattable>(instance, TO_URI_COMPONENT, Type.FUNCTION);\r\n}\r\n\r\n/**\r\n * Parses a string for valid query param entries and pipes them through a handler.\r\n * @param query\r\n * @param entryHandler\r\n * @param deserialize Default is true.\r\n * @param decodeValues Default is true.\r\n */\r\nexport function parse(\r\n\tquery:string,\r\n\tentryHandler:(key:string, value:Primitive)=>void,\r\n\tdeserialize:boolean = true,\r\n\tdecodeValues:boolean = true):void\r\n{\r\n\tif(query && (query = query.replace(/^\\s*\\?+/, '')))\r\n\t{\r\n\t\tvar entries = query.split(ENTRY_SEPARATOR);\r\n\t\tfor(let entry of entries)\r\n\t\t{\r\n\t\t\t/*\r\n\t\t\t * Since it is technically possible to have multiple '=' we need to identify the first one.\r\n\t\t\t * And if there is no '=' then the entry is ignored.\r\n\t\t\t */\r\n\t\t\tvar si = entry.indexOf(KEY_VALUE_SEPARATOR);\r\n\t\t\tif(si!= -1)\r\n\t\t\t{\r\n\t\t\t\tvar key = entry.substring(0, si);\r\n\t\t\t\tvar value = <any>entry.substring(si + 1);\r\n\t\t\t\tif(decodeValues) value = decodeURIComponent(value);\r\n\t\t\t\tif(deserialize) value = Serialization.toPrimitive(value);\r\n\t\t\t\tentryHandler(key, value);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Parses a string for valid query params and returns a key-value map of the entries.\r\n * @param query\r\n * @param deserialize Default is true.\r\n * @param decodeValues Default is true.\r\n * @returns {IMap<Primitive>}\r\n */\r\nexport function parseToMap(\r\n\tquery:string,\r\n\tdeserialize:boolean = true,\r\n\tdecodeValues:boolean = true):IMap<Primitive|Primitive[]>\r\n{\r\n\tvar result:IMap<Primitive|Primitive[]> = {};\r\n\tparse(query,\r\n\t\t(key, value)=>\r\n\t\t{\r\n\t\t\tif((key) in (result))\r\n\t\t\t{\r\n\t\t\t\tvar prev:any = result[key];\r\n\t\t\t\tif(!(Array.isArray(prev)))\r\n\t\t\t\t\tresult[key] = prev = [prev];\r\n\t\t\t\tprev.push(value);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tresult[key] = value;\r\n\t\t},\r\n\t\tdeserialize,\r\n\t\tdecodeValues);\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Parses a string for valid query params and returns a key-value pair array of the entries.\r\n * @param query\r\n * @param deserialize Default is true.\r\n * @param decodeValues Default is true.\r\n * @returns {IKeyValuePair<string, Primitive>[]}\r\n */\r\nexport function parseToArray(\r\n\tquery:string,\r\n\tdeserialize:boolean = true,\r\n\tdecodeValues:boolean = true):IStringKeyValuePair<Primitive>[]\r\n{\r\n\tvar result:IStringKeyValuePair<Primitive>[] = [];\r\n\tparse(query,\r\n\t\t(key, value)=> {result.push({key: key, value: value});},\r\n\t\tdeserialize,\r\n\t\tdecodeValues\r\n\t);\r\n\treturn result;\r\n}\r\n\r\n\r\nexport module Separator\r\n{\r\n\texport const Query:string = QUERY_SEPARATOR;\r\n\texport const Entry:string = ENTRY_SEPARATOR;\r\n\texport const KeyValue:string = KEY_VALUE_SEPARATOR;\r\n}\r\nObject.freeze(Separator);\r\n\r\n"]}