{"version":3,"sources":["System/Collections/Set.js","System/Collections/Set.ts"],"names":[],"mappings":";;;;AAIA;;;;;;;;;;;;;;ACEA,IAAA,UAAA,QAAmB,UAAnB,CAAA;AACA,IAAA,sBAAA,QAAgC,iCAAhC,CAAA;AACA,IAAA,YAAA,QAAsB,WAAtB,CAAA;AAMA,IAAM,QAAQ,OAAR;;IAEN;;;;;;;;;;;iCAGoB,QAA6B;AAE/C,mBAAO,IAAI,GAAJ,CAAW,MAAX,CAAP,CAF+C;;;;qCAOzB,MAAM;AAE5B,gBAAI,IAAI,IAAJ,CAFwB;AAG5B,gBAAG,CAAC,EAAE,QAAF,CAAW,IAAX,CAAD,EACH;AACC,oBAAI,cAAc,kDAAd,CADL;AAEC,oBAAG,CAAC,QAAA,IAAA,CAAK,WAAL,CAAiB,IAAjB,CAAD,EACF,MAAM,IAAI,oBAAA,iBAAA,CAAkB,MAAtB,EAA8B,sEAA9B,CAAN,CADD;AAGA,oBAAI,IAAI,EAAE,SAAF,CALT;AAMC,oBAAI,IAAI,KAAK,EAAE,IAAF,CAAL,CANT;AAOC,oBAAG,CAAC,CAAD,EAAI,EAAE,SAAF,GAAc,IAAI,EAAJ,CAArB;AACA,oBAAG,CAAC,CAAD,EAAI,EAAE,IAAF,IAAU,IAAI,EAAJ,CAAjB;AACA,oBAAI,OAA+B,EAAC,OAAO,IAAP,EAAhC,CATL;AAUC,kBAAE,OAAF,GAAY,OAAZ,CAAoB,IAApB,EAVD;AAWC,kBAAO,IAAP,IAAe,IAAf,CAXD;AAYC,uBAAO,IAAP,CAZD;aADA;AAeA,mBAAO,KAAP,CAlB4B;;;;yCAqBL;AAEvB,iBAAK,KAAK,SAAL,EAAgB,CAArB,EAFuB;AAGvB,8CAlCF,kDAkCE,CAHuB;;;;qCAMJ;AAEnB,uCAvCF,8CAuCE,CAFmB;AAGnB,iBAAK,SAAL,GAAiB,IAAjB,CAHmB;;;;iCAMD,MAAM;AAExB,gBAAI,IAAI,KAAK,SAAL;gBAAgB,IAAI,KAAK,SAAS,kDAAT,CAAL,CAFJ;AAIxB,mBAAO,KAAK,EAAO,IAAP,CAAL,CAJiB;;;;wCAOC,MAA6B;gBAArB,4DAAa,wBAAQ;;AAEtD,gBAAG,QAAM,CAAN,EAAS,OAAO,CAAP,CAAZ;AAEA,gBAAI,IAAO,KAAK,SAAL;gBACP,IAAO,KAAK,SAAS,kDAAT,CAAL;gBACP,OAAO,KAAK,EAAO,IAAP,CAAL,CAN2C;AAQtD,gBAAG,IAAH,EACA;AACC,uBAAO,EAAO,IAAP,CAAP,CADD;AAEC,oBAAI,IAAI,KAAK,IAAL,CAFT;AAGC,oBAAG,KAAK,EAAE,UAAF,CAAa,IAAb,CAAL,EACH;AACC,2BAAO,CAAP,CADD;iBADA;aAJD;AAUA,mBAAO,CAAP,CAlBsD;;;;WAlDxD;EACQ,UAAA,OAAA;;AADK,QAAA,GAAA,GAAG,GAAH;AAyEb,SAAA,IAAA,CAAc,GAAd,EAA6C;QAAhB,8DAAe,iBAAC;;AAE5C,QAAG,OAAO,KAAP,EACH;;;;;;AACC,iCAAe,OAAO,IAAP,CAAY,GAAZ,2BAAf,oGACA;oBADQ,kBACR;;AACC,oBAAI,IAAI,IAAI,GAAJ,CAAJ,CADL;AAEC,uBAAO,IAAI,GAAJ,CAAP,CAFD;AAGC,qBAAK,CAAL,EAAQ,QAAQ,CAAR,CAAR,CAHD;aADA;;;;;;;;;;;;;;SADD;KADA;CAFD;AAaA,OAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA,EAAA,OAAA,IAAA,EAAA;ADjCA,QAAQ,OAAR,GCiCe,GDjCf","file":"System/Collections/Set.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst Types_1 = require(\"../Types\");\nconst ArgumentException_1 = require(\"../Exceptions/ArgumentException\");\nconst SetBase_1 = require(\"./SetBase\");\nconst OTHER = 'other';\nclass Set extends SetBase_1.SetBase {\n    newUsing(source) {\n        return new Set(source);\n    }\n    _addInternal(item) {\n        var _ = this;\n        if (!_.contains(item)) {\n            var type = typeof item;\n            if (!Types_1.Type.isPrimitive(type))\n                throw new ArgumentException_1.ArgumentException(\"item\", \"A Set can only index primitives.  Complex objects require a HashSet.\");\n            var r = _._registry;\n            var t = r && r[type];\n            if (!r)\n                _._registry = r = {};\n            if (!t)\n                r[type] = t = {};\n            var node = { value: item };\n            _._getSet().addNode(node);\n            t[item] = node;\n            return true;\n        }\n        return false;\n    }\n    _clearInternal() {\n        wipe(this._registry, 2);\n        return super._clearInternal();\n    }\n    _onDispose() {\n        super._onDispose();\n        this._registry = null;\n    }\n    _getNode(item) {\n        var r = this._registry, t = r && r[typeof item];\n        return t && t[item];\n    }\n    _removeInternal(item, max = Infinity) {\n        if (max === 0)\n            return 0;\n        var r = this._registry, t = r && r[typeof item], node = t && t[item];\n        if (node) {\n            delete t[item];\n            var s = this._set;\n            if (s && s.removeNode(node)) {\n                return 1;\n            }\n        }\n        return 0;\n    }\n}\nexports.Set = Set;\nfunction wipe(map, depth = 1) {\n    if (map && depth) {\n        for (var key of Object.keys(map)) {\n            var v = map[key];\n            delete map[key];\n            wipe(v, depth - 1);\n        }\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Set;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n\r\nimport {Type} from \"../Types\";\r\nimport {ArgumentException} from \"../Exceptions/ArgumentException\";\r\nimport {SetBase} from \"./SetBase\";\r\nimport {IMap} from \"./Dictionaries/IDictionary\";\r\nimport {ILinkedNodeWithValue} from \"./ILinkedListNode\";\r\nimport {Primitive} from \"../Primitive\";\r\nimport {IEnumerableOrArray} from \"./IEnumerableOrArray\";\r\n\r\nconst OTHER = 'other';\r\n\r\nexport class Set<T extends Primitive>\r\nextends SetBase<T>\r\n{\r\n\tprotected newUsing(source?:IEnumerableOrArray<T>):Set<T>\r\n\t{\r\n\t\treturn new Set<T>(source);\r\n\t}\r\n\r\n\tprivate _registry:IMap<IMap<ILinkedNodeWithValue<T>>>;\r\n\r\n\tprotected _addInternal(item:T):boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(!_.contains(item))\r\n\t\t{\r\n\t\t\tvar type = typeof item;\r\n\t\t\tif(!Type.isPrimitive(type))\r\n\t\t\t\tthrow new ArgumentException(\"item\", \"A Set can only index primitives.  Complex objects require a HashSet.\");\r\n\r\n\t\t\tvar r = _._registry;\r\n\t\t\tvar t = r && r[type];\r\n\t\t\tif(!r) _._registry = r = {};\r\n\t\t\tif(!t) r[type] = t = {};\r\n\t\t\tvar node:ILinkedNodeWithValue<T> = {value: item};\r\n\t\t\t_._getSet().addNode(node);\r\n\t\t\tt[<any>item] = node;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprotected _clearInternal():number\r\n\t{\r\n\t\twipe(this._registry, 2);\r\n\t\treturn super._clearInternal();\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._registry = null;\r\n\t}\r\n\r\n\tprotected _getNode(item:T):ILinkedNodeWithValue<T>\r\n\t{\r\n\t\tvar r = this._registry, t = r && r[typeof item];\r\n\r\n\t\treturn t && t[<any>item];\r\n\t}\r\n\r\n\tprotected _removeInternal(item:T, max:number = Infinity):number\r\n\t{\r\n\t\tif(max===0) return 0;\r\n\r\n\t\tvar r    = this._registry,\r\n\t\t    t    = r && r[typeof item],\r\n\t\t    node = t && t[<any>item];\r\n\r\n\t\tif(node)\r\n\t\t{\r\n\t\t\tdelete t[<any>item];\r\n\t\t\tvar s = this._set;\r\n\t\t\tif(s && s.removeNode(node))\r\n\t\t\t{\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\t}\r\n\r\n}\r\n\r\nfunction wipe(map:IMap<any>, depth:number = 1):void\r\n{\r\n\tif(map && depth)\r\n\t{\r\n\t\tfor(var key of Object.keys(map))\r\n\t\t{\r\n\t\t\tvar v = map[key];\r\n\t\t\tdelete map[key];\r\n\t\t\twipe(v, depth - 1);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport default Set;"]}