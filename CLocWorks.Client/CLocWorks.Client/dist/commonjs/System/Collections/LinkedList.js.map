{"version":3,"sources":["System/Collections/LinkedList.js","System/Collections/LinkedList.ts"],"names":[],"mappings":"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","file":"System/Collections/LinkedList.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Based Upon: http://msdn.microsoft.com/en-us/library/he2s3bh7%28v=vs.110%29.aspx\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst Compare_1 = require(\"../Compare\");\nconst LinkedNodeList_1 = require(\"./LinkedNodeList\");\nconst InvalidOperationException_1 = require(\"../Exceptions/InvalidOperationException\");\nconst ArgumentNullException_1 = require(\"../Exceptions/ArgumentNullException\");\nconst CollectionBase_1 = require(\"./CollectionBase\");\nclass InternalNode {\n    constructor(value, previous, next) {\n        this.value = value;\n        this.previous = previous;\n        this.next = next;\n    }\n    assertDetached() {\n        if (this.next || this.previous)\n            throw new InvalidOperationException_1.InvalidOperationException(\"Adding a node that is already placed.\");\n    }\n}\nfunction ensureExternal(node, list) {\n    if (!node)\n        return null;\n    if (!list)\n        throw new ArgumentNullException_1.ArgumentNullException(\"list\");\n    var external = node.external;\n    if (!external)\n        node.external = external = new LinkedListNode(list, node);\n    return external;\n}\nfunction getInternal(node, list) {\n    if (!node)\n        throw new ArgumentNullException_1.ArgumentNullException(\"node\");\n    if (!list)\n        throw new ArgumentNullException_1.ArgumentNullException(\"list\");\n    if (node.list != list)\n        throw new InvalidOperationException_1.InvalidOperationException(\"Provided node does not belong to this list.\");\n    var n = node._nodeInternal;\n    if (!n)\n        throw new InvalidOperationException_1.InvalidOperationException(\"Provided node is not valid.\");\n    return n;\n}\nclass LinkedList extends CollectionBase_1.CollectionBase {\n    constructor(source, equalityComparer = Compare_1.areEqual) {\n        super(null, equalityComparer);\n        var _ = this;\n        _._listInternal = new LinkedNodeList_1.LinkedNodeList();\n        _._importEntries(source);\n    }\n    getCount() {\n        return this._listInternal.unsafeCount;\n    }\n    _addInternal(entry) {\n        this._listInternal.addNode(new InternalNode(entry));\n        return true;\n    }\n    _removeInternal(entry, max = Infinity) {\n        var _ = this, equals = _._equalityComparer, list = _._listInternal, removedCount = 0;\n        list.forEach(node => {\n            if (equals(entry, node.value) && list.removeNode(node))\n                removedCount++;\n            return removedCount < max;\n        });\n        return removedCount;\n    }\n    _clearInternal() {\n        return this._listInternal.clear();\n    }\n    forEach(action, useCopy = false) {\n        return useCopy\n            ? super.forEach(action, useCopy)\n            : this._listInternal.forEach((node, i) => action(node.value, i));\n    }\n    getEnumerator() {\n        return LinkedNodeList_1.LinkedNodeList.valueEnumeratorFrom(this._listInternal);\n    }\n    _findFirst(entry) {\n        var _ = this, equals = _._equalityComparer, next = _._listInternal.first;\n        while (next) {\n            if (equals(entry, next.value))\n                return next;\n            next = next.next;\n        }\n        return null;\n    }\n    _findLast(entry) {\n        var _ = this, equals = _._equalityComparer, prev = _._listInternal.last;\n        while (prev) {\n            if (equals(entry, prev.value))\n                return prev;\n            prev = prev.previous;\n        }\n        return null;\n    }\n    removeOnce(entry) {\n        return this.remove(entry, 1) !== 0;\n    }\n    get first() {\n        return ensureExternal(this._listInternal.first, this);\n    }\n    get last() {\n        return ensureExternal(this._listInternal.last, this);\n    }\n    getValueAt(index) {\n        var node = this._listInternal.getNodeAt(index);\n        if (!node)\n            return node && node.value || void (0);\n    }\n    getNodeAt(index) {\n        return ensureExternal(this._listInternal.getNodeAt(index), this);\n    }\n    find(entry) {\n        return ensureExternal(this._findFirst(entry), this);\n    }\n    findLast(entry) {\n        return ensureExternal(this._findLast(entry), this);\n    }\n    addFirst(entry) {\n        this._listInternal.addNodeBefore(new InternalNode(entry));\n        this._signalModification(true);\n    }\n    addLast(entry) {\n        this.add(entry);\n    }\n    removeFirst() {\n        var _ = this, first = _._listInternal.first;\n        if (first && _._listInternal.removeNode(first))\n            _._signalModification(true);\n    }\n    removeLast() {\n        var _ = this, last = _._listInternal.last;\n        if (last && _._listInternal.removeNode(last))\n            _._signalModification(true);\n    }\n    removeNode(node) {\n        var _ = this;\n        if (_._listInternal.removeNode(getInternal(node, _))) {\n            _._signalModification(true);\n            return true;\n        }\n        return false;\n    }\n    addBefore(before, entry) {\n        var _ = this;\n        _._listInternal.addNodeBefore(new InternalNode(entry), getInternal(before, _));\n        _._signalModification(true);\n    }\n    addAfter(after, entry) {\n        var _ = this;\n        _._listInternal.addNodeAfter(new InternalNode(entry), getInternal(after, _));\n        _._signalModification(true);\n    }\n    addNodeBefore(node, before) {\n        var _ = this;\n        _._listInternal.addNodeBefore(getInternal(before, _), getInternal(node, _));\n        _._signalModification(true);\n    }\n    addNodeAfter(node, after) {\n        var _ = this;\n        this._listInternal.addNodeAfter(getInternal(after, _), getInternal(node, _));\n        _._signalModification(true);\n    }\n}\nexports.LinkedList = LinkedList;\nclass LinkedListNode {\n    constructor(_list, _nodeInternal) {\n        this._list = _list;\n        this._nodeInternal = _nodeInternal;\n    }\n    get list() {\n        return this._list;\n    }\n    get previous() {\n        return ensureExternal(this._nodeInternal.previous, this._list);\n    }\n    get next() {\n        return ensureExternal(this._nodeInternal.next, this._list);\n    }\n    get value() {\n        return this._nodeInternal.value;\n    }\n    set value(v) {\n        this._nodeInternal.value = v;\n    }\n    addBefore(entry) {\n        this._list.addBefore(this, entry);\n    }\n    addAfter(entry) {\n        this._list.addAfter(this, entry);\n    }\n    addNodeBefore(before) {\n        this._list.addNodeBefore(this, before);\n    }\n    addNodeAfter(after) {\n        this._list.addNodeAfter(this, after);\n    }\n    remove() {\n        this._list.removeNode(this);\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = LinkedList;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Based Upon: http://msdn.microsoft.com/en-us/library/he2s3bh7%28v=vs.110%29.aspx\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n\r\nimport {areEqual} from \"../Compare\";\r\nimport {LinkedNodeList} from \"./LinkedNodeList\";\r\nimport {InvalidOperationException} from \"../Exceptions/InvalidOperationException\";\r\nimport {ArgumentNullException} from \"../Exceptions/ArgumentNullException\";\r\nimport {CollectionBase} from \"./CollectionBase\";\r\nimport {ILinkedListNode, ILinkedNode, INodeWithValue} from \"./ILinkedListNode\";\r\nimport {IEnumerator} from \"./Enumeration/IEnumerator\";\r\nimport {Predicate, Action, EqualityComparison} from \"../FunctionTypes\";\r\nimport {ILinkedList} from \"./ILinkedList\";\r\nimport {IEnumerableOrArray} from \"./IEnumerableOrArray\";\r\n\r\n/*****************************\r\n * IMPORTANT NOTES ABOUT PERFORMANCE:\r\n * http://jsperf.com/simulating-a-queue\r\n *\r\n * Adding to an array is very fast, but modifying is slow.\r\n * LinkedList wins when modifying contents.\r\n * http://stackoverflow.com/questions/166884/array-versus-linked-list\r\n *****************************/\r\n\r\n/*\r\n * An internal node is used to manage the order without exposing underlying link chain to the consumer.\r\n */\r\nclass InternalNode<T>\r\nimplements ILinkedNode<InternalNode<T>>, INodeWithValue<T>\r\n{\r\n\tconstructor(\r\n\t\tpublic value?:T,\r\n\t\tpublic previous?:InternalNode<T>,\r\n\t\tpublic next?:InternalNode<T>)\r\n\t{\r\n\t}\r\n\r\n\texternal:ILinkedListNode<T>;\r\n\r\n\tassertDetached():void\r\n\t{\r\n\t\tif(this.next || this.previous)\r\n\t\t\tthrow new InvalidOperationException(\r\n\t\t\t\t\"Adding a node that is already placed.\");\r\n\t}\r\n\r\n}\r\n\r\nfunction ensureExternal<T>(node:InternalNode<T>, list:LinkedList<T>):ILinkedListNode<T>\r\n{\r\n\tif(!node)\r\n\t\treturn null;\r\n\tif(!list)\r\n\t\tthrow new ArgumentNullException(\"list\");\r\n\r\n\tvar external:ILinkedListNode<T> = node.external;\r\n\tif(!external)\r\n\t\tnode.external = external = new LinkedListNode<T>(list, node);\r\n\r\n\treturn external;\r\n}\r\n\r\nfunction getInternal<T>(node:ILinkedListNode<T>, list:LinkedList<T>):InternalNode<T>\r\n{\r\n\tif(!node)\r\n\t\tthrow new ArgumentNullException(\"node\");\r\n\tif(!list)\r\n\t\tthrow new ArgumentNullException(\"list\");\r\n\r\n\tif(node.list!=list)\r\n\t\tthrow new InvalidOperationException(\r\n\t\t\t\"Provided node does not belong to this list.\");\r\n\r\n\tvar n:InternalNode<T> = (<any>node)._nodeInternal;\r\n\tif(!n)\r\n\t\tthrow new InvalidOperationException(\r\n\t\t\t\"Provided node is not valid.\");\r\n\r\n\treturn n;\r\n}\r\n\r\nexport class LinkedList<T>\r\nextends CollectionBase<T> implements ILinkedList<T>\r\n{\r\n\tprivate _listInternal:LinkedNodeList<InternalNode<T>>;\r\n\r\n\tconstructor(\r\n\t\tsource?:IEnumerableOrArray<T>,\r\n\t\tequalityComparer:EqualityComparison<T> = areEqual)\r\n\t{\r\n\t\tsuper(null, equalityComparer);\r\n\t\tvar _ = this;\r\n\t\t_._listInternal = new LinkedNodeList<InternalNode<T>>();\r\n\t\t_._importEntries(source);\r\n\t}\r\n\r\n\tprotected getCount():number\r\n\t{\r\n\t\treturn this._listInternal.unsafeCount;\r\n\t}\r\n\r\n\tprotected _addInternal(entry:T):boolean\r\n\t{\r\n\t\tthis._listInternal.addNode(new InternalNode(entry));\r\n\t\treturn true;\r\n\t}\r\n\r\n\tprotected _removeInternal(entry:T, max:number = Infinity):number\r\n\t{\r\n\t\tvar _            = this,\r\n\t\t    equals       = _._equalityComparer,\r\n\t\t    list         = _._listInternal,\r\n\t\t    removedCount = 0;\r\n\r\n\t\tlist.forEach(node=>\r\n\t\t{\r\n\t\t\tif(equals(entry, node.value) && list.removeNode(node))\r\n\t\t\t\tremovedCount++;\r\n\r\n\t\t\treturn removedCount<max;\r\n\t\t});\r\n\r\n\t\treturn removedCount;\r\n\t}\r\n\r\n\tprotected _clearInternal():number\r\n\t{\r\n\t\treturn this._listInternal.clear();\r\n\t}\r\n\r\n\r\n\tforEach(\r\n\t\taction:Predicate<T> | Action<T>,\r\n\t\tuseCopy:boolean = false):number\r\n\t{\r\n\t\treturn useCopy\r\n\t\t\t? super.forEach(action, useCopy)\r\n\t\t\t: this._listInternal.forEach((node, i)=>action(node.value, i));\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// #region IEnumerable<T>\r\n\tgetEnumerator():IEnumerator<T>\r\n\t{\r\n\t\treturn LinkedNodeList.valueEnumeratorFrom<T>(<any>this._listInternal);\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\tprivate _findFirst(entry:T):InternalNode<T>\r\n\t{\r\n\t\t//noinspection UnnecessaryLocalVariableJS\r\n\t\tvar _      = this,\r\n\t\t    equals = _._equalityComparer,\r\n\t\t    next   = _._listInternal.first;\r\n\t\twhile(next)\r\n\t\t{\r\n\t\t\tif(equals(entry, next.value))\r\n\t\t\t\treturn next;\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tprivate _findLast(entry:T):InternalNode<T>\r\n\t{\r\n\t\t//noinspection UnnecessaryLocalVariableJS\r\n\t\tvar _      = this,\r\n\t\t    equals = _._equalityComparer,\r\n\t\t    prev   = _._listInternal.last;\r\n\t\twhile(prev)\r\n\t\t{\r\n\t\t\tif(equals(entry, prev.value))\r\n\t\t\t\treturn prev;\r\n\t\t\tprev = prev.previous;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tremoveOnce(entry:T):boolean\r\n\t{\r\n\t\treturn this.remove(entry, 1)!==0;\r\n\t}\r\n\r\n\tget first():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._listInternal.first, this);\r\n\t}\r\n\r\n\tget last():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._listInternal.last, this);\r\n\t}\r\n\r\n\t// get methods are available for convenience but is an n*index operation.\r\n\r\n\r\n\tgetValueAt(index:number):T\r\n\t{\r\n\t\tvar node = this._listInternal.getNodeAt(index);\r\n\t\tif(!node)\r\n\t\t\treturn node && node.value || void(0);\r\n\t}\r\n\r\n\tgetNodeAt(index:number):ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._listInternal.getNodeAt(index), this);\r\n\t}\r\n\r\n\tfind(entry:T):ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._findFirst(entry), this);\r\n\t}\r\n\r\n\tfindLast(entry:T):ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._findLast(entry), this);\r\n\t}\r\n\r\n\taddFirst(entry:T):void\r\n\t{\r\n\t\tthis._listInternal.addNodeBefore(new InternalNode(entry));\r\n\t\tthis._signalModification(true);\r\n\t}\r\n\r\n\taddLast(entry:T):void\r\n\t{\r\n\t\tthis.add(entry);\r\n\t}\r\n\r\n\tremoveFirst():void\r\n\t{\r\n\t\tvar _ = this, first = _._listInternal.first;\r\n\t\tif(first && _._listInternal.removeNode(first))\r\n\t\t\t_._signalModification(true);\r\n\t}\r\n\r\n\tremoveLast():void\r\n\t{\r\n\t\tvar _ = this, last = _._listInternal.last;\r\n\t\tif(last && _._listInternal.removeNode(last))\r\n\t\t\t_._signalModification(true);\r\n\t}\r\n\r\n\t// Returns true if successful and false if not found (already removed).\r\n\tremoveNode(node:ILinkedListNode<T>):boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\r\n\t\tif(_._listInternal.removeNode(getInternal(node, _)))\r\n\t\t{\r\n\t\t\t_._signalModification(true);\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\taddBefore(before:ILinkedListNode<T>, entry:T):void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_._listInternal.addNodeBefore(\r\n\t\t\tnew InternalNode(entry),\r\n\t\t\tgetInternal(before, _)\r\n\t\t);\r\n\r\n\t\t_._signalModification(true);\r\n\t}\r\n\r\n\taddAfter(after:ILinkedListNode<T>, entry:T):void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_._listInternal.addNodeAfter(\r\n\t\t\tnew InternalNode(entry),\r\n\t\t\tgetInternal(after, _)\r\n\t\t);\r\n\r\n\t\t_._signalModification(true);\r\n\t}\r\n\r\n\taddNodeBefore(node:ILinkedListNode<T>, before:ILinkedListNode<T>):void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_._listInternal.addNodeBefore(\r\n\t\t\tgetInternal(before, _),\r\n\t\t\tgetInternal(node, _)\r\n\t\t);\r\n\r\n\t\t_._signalModification(true);\r\n\t}\r\n\r\n\taddNodeAfter(node:ILinkedListNode<T>, after:ILinkedListNode<T>):void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tthis._listInternal.addNodeAfter(\r\n\t\t\tgetInternal(after, _),\r\n\t\t\tgetInternal(node, _)\r\n\t\t);\r\n\r\n\t\t_._signalModification(true);\r\n\t}\r\n\r\n\r\n}\r\n\r\n// Use an internal node class to prevent mucking up the LinkedList.\r\nclass LinkedListNode<T> implements ILinkedListNode<T>\r\n{\r\n\tconstructor(\r\n\t\tprivate _list:LinkedList<T>,\r\n\t\tprivate _nodeInternal:InternalNode<T>)\r\n\t{\r\n\t}\r\n\r\n\tget list():LinkedList<T>\r\n\t{\r\n\t\treturn this._list;\r\n\t}\r\n\r\n\tget previous():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._nodeInternal.previous, this._list);\r\n\t}\r\n\r\n\tget next():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._nodeInternal.next, this._list);\r\n\t}\r\n\r\n\tget value():T\r\n\t{\r\n\t\treturn this._nodeInternal.value;\r\n\t}\r\n\r\n\tset value(v:T)\r\n\t{\r\n\t\tthis._nodeInternal.value = v;\r\n\t}\r\n\r\n\taddBefore(entry:T):void\r\n\t{\r\n\t\tthis._list.addBefore(this, entry);\r\n\t}\r\n\r\n\taddAfter(entry:T):void\r\n\t{\r\n\t\tthis._list.addAfter(this, entry);\r\n\t}\r\n\r\n\taddNodeBefore(before:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._list.addNodeBefore(this, before);\r\n\t}\r\n\r\n\taddNodeAfter(after:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._list.addNodeAfter(this, after);\r\n\t}\r\n\r\n\tremove():void\r\n\t{\r\n\t\tthis._list.removeNode(this);\r\n\t}\r\n\r\n}\r\n\r\nexport default LinkedList;\r\n"]}