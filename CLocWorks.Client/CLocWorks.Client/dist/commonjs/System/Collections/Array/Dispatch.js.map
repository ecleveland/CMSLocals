{"version":3,"sources":["System/Collections/Array/Dispatch.js","System/Collections/Array/Dispatch.ts"],"names":[],"mappings":";;;;AAIA;;ACCA,IAAA,UAAA,QAAmB,aAAnB,CAAA;AACA,IAAA,YAAA,QAAmB,WAAnB,CAAA;AAGA,IAAM,QAAY,KAAK,CAAL;AA4BlB,SAAA,MAAA,CACC,SADD,EAEC,OAFD,EAEY,IAFZ,EAE8C;AAE7C,QAAG,aAAa,UAAU,MAAV,EAChB;AACC,aAAI,IAAI,IAAI,CAAJ,EAAO,MAAM,UAAU,MAAV,EAAkB,IAAE,GAAF,EAAO,GAA9C,EACA;AACC,gBAAI,KAAc,UAAU,CAAV,CAAd,CADL;AAEC,gBAAG,CAAC,EAAD,EAAK,SAAR;AACA,gBACA;AACC,mBAAG,OAAH,EADD;aADA,CAIA,OAAM,EAAN,EACA;AACC,oBAAG,CAAC,IAAD,EACF,MAAM,EAAN,CADD,KAEK,IAAG,QAAA,IAAA,CAAK,UAAL,CAAgB,IAAhB,CAAH,EACJ,KAAK,EAAL,EAAS,CAAT,EADI;aAJN;SARD;KAFD;CAJD;AAAgB,QAAA,MAAA,GAAM,MAAN;AAkChB,SAAA,MAAA,CACC,SADD,EAEC,OAFD,EAEY,IAFZ,EAE8C;AAG7C,QAAG,CAAC,SAAD,EAAY,OAAO,IAAP,CAAf;AAEA,QAAI,SAAe,UAAA,IAAA,CAAK,SAAL,CAAf,CALyC;AAM7C,QAAG,UAAU,MAAV,EACH;AAEC,aAAI,IAAI,IAAI,CAAJ,EAAO,MAAM,OAAO,MAAP,EAAe,IAAE,GAAF,EAAO,GAA3C,EACA;AACC,gBAAI,KAAc,OAAO,CAAP,CAAd,CADL;AAEC,gBACA;AACC,uBAAO,CAAP,IAAY,KACT,GAAG,OAAH,CADS,GAET,KAFS,CADb;aADA,CAMA,OAAM,EAAN,EACA;AACC,uBAAO,CAAP,IAAY,KAAZ,CADD;AAEC,oBAAG,CAAC,IAAD,EACF,MAAM,EAAN,CADD,KAEK,IAAG,QAAA,IAAA,CAAK,UAAL,CAAgB,IAAhB,CAAH,EACJ,KAAK,EAAL,EAAS,CAAT,EADI;aALN;SATD;KAHD;AAuBA,WAAO,MAAP,CA7B6C;CAF9C;AAAgB,QAAA,MAAA,GAAM,MAAN;AA2ChB,SAAA,QAAA,CACC,SADD,EAEC,OAFD,EAEY,IAFZ,EAE8C;AAE7C,WAAO,UAAA,IAAA,CAAK,SAAL,CAAP,EAAwB,OAAxB,EAAiC,IAAjC,EAF6C;CAF9C;AAAgB,QAAA,QAAA,GAAQ,QAAR;AAOhB,OAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA,EAAA,OAAA,IAAA,EAAA;ADjEA,QAAQ,OAAR,GCiEe,QDjEf","file":"System/Collections/Array/Dispatch.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst Types_1 = require(\"../../Types\");\nconst Utility_1 = require(\"./Utility\");\nconst VOID0 = void (0);\nfunction unsafe(listeners, payload, trap) {\n    if (listeners && listeners.length) {\n        for (let i = 0, len = listeners.length; i < len; i++) {\n            let fn = listeners[i];\n            if (!fn)\n                continue;\n            try {\n                fn(payload);\n            }\n            catch (ex) {\n                if (!trap)\n                    throw ex;\n                else if (Types_1.Type.isFunction(trap))\n                    trap(ex, i);\n            }\n        }\n    }\n}\nexports.unsafe = unsafe;\nfunction mapped(listeners, payload, trap) {\n    if (!listeners)\n        return null;\n    var result = Utility_1.copy(listeners);\n    if (listeners.length) {\n        for (let i = 0, len = result.length; i < len; i++) {\n            let fn = result[i];\n            try {\n                result[i] = fn\n                    ? fn(payload)\n                    : VOID0;\n            }\n            catch (ex) {\n                result[i] = VOID0;\n                if (!trap)\n                    throw ex;\n                else if (Types_1.Type.isFunction(trap))\n                    trap(ex, i);\n            }\n        }\n    }\n    return result;\n}\nexports.mapped = mapped;\nfunction dispatch(listeners, payload, trap) {\n    unsafe(Utility_1.copy(listeners), payload, trap);\n}\nexports.dispatch = dispatch;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = dispatch;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {Type} from \"../../Types\";\r\nimport {copy} from \"./Utility\";\r\nimport {IArray} from \"./IArray\";\r\n\r\nconst VOID0:any = void(0);\r\n\r\nexport interface DispatchErrorHandler\r\n{\r\n\t(ex?:any, i?:number):void;\r\n}\r\n\r\n/**\r\n * Simply takes a payload and passes it to all the listeners.\r\n *\r\n * While dispatching:\r\n * * This is an unsafe method if by chance any of the listeners modify the array.\r\n * * It cannot prevent changes to the payload.\r\n *\r\n * Improving safety:\r\n * * Only use a local array that isn't exposed to the listeners.\r\n * * Use the dispatch method instead as it makes a copy of the listeners array.\r\n * * Freeze the listeners array so it can't be modified.\r\n * * Freeze the payload.\r\n *\r\n * Specifying trap will catch any errors and pass them along if trap is a function.\r\n * A payload is used instead of arguments for easy typing.\r\n *\r\n *\r\n * @param listeners\r\n * @param payload\r\n * @param trap\r\n */\r\nexport function unsafe<T>(\r\n\tlisteners:IArray<(payload:T)=>any>,\r\n\tpayload:T, trap?:boolean|DispatchErrorHandler):void\r\n{\r\n\tif(listeners && listeners.length)\r\n\t{\r\n\t\tfor(let i = 0, len = listeners.length; i<len; i++)\r\n\t\t{\r\n\t\t\tlet fn:Function = listeners[i];\r\n\t\t\tif(!fn) continue; // Ignore null refs.\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tfn(payload);\r\n\t\t\t}\r\n\t\t\tcatch(ex)\r\n\t\t\t{\r\n\t\t\t\tif(!trap)\r\n\t\t\t\t\tthrow ex;\r\n\t\t\t\telse if(Type.isFunction(trap))\r\n\t\t\t\t\ttrap(ex, i);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Simply takes a payload and passes it to all the listeners.\r\n * Returns the results in an array that matches the indexes of the listeners.\r\n *\r\n * @param listeners\r\n * @param payload\r\n * @param trap\r\n * @returns {any}\r\n */\r\nexport function mapped<T,TResult>(\r\n\tlisteners:IArray<(payload:T)=>TResult>,\r\n\tpayload:T, trap?:boolean|DispatchErrorHandler):TResult[]\r\n{\r\n\r\n\tif(!listeners) return null;\r\n\t// Reuse the copy as the array result.\r\n\tvar result:any[] = copy(listeners);\r\n\tif(listeners.length)\r\n\t{\r\n\r\n\t\tfor(let i = 0, len = result.length; i<len; i++)\r\n\t\t{\r\n\t\t\tlet fn:Function = result[i];\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tresult[i] = fn // Ignore null refs.\r\n\t\t\t\t\t? fn(payload)\r\n\t\t\t\t\t: VOID0;\r\n\t\t\t}\r\n\t\t\tcatch(ex)\r\n\t\t\t{\r\n\t\t\t\tresult[i] = VOID0;\r\n\t\t\t\tif(!trap)\r\n\t\t\t\t\tthrow ex;\r\n\t\t\t\telse if(Type.isFunction(trap))\r\n\t\t\t\t\ttrap(ex, i);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\n/**\r\n * Simply takes a payload and passes it to all the listeners.\r\n * Makes a copy of the listeners before calling dispatchUnsafe.\r\n *\r\n * @param listeners\r\n * @param payload\r\n * @param trap\r\n */\r\nexport function dispatch<T>(\r\n\tlisteners:IArray<(payload:T)=>any>,\r\n\tpayload:T, trap?:boolean|DispatchErrorHandler):void\r\n{\r\n\tunsafe(copy(listeners), payload, trap);\r\n}\r\n\r\nexport default dispatch;"]}