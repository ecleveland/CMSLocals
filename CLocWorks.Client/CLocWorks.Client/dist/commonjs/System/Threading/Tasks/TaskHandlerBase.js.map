{"version":3,"sources":["System/Threading/Tasks/TaskHandlerBase.js","System/Threading/Tasks/TaskHandlerBase.ts"],"names":[],"mappings":";;;;AAIA;;;;;;;;;;ACCA,IAAA,mBAAA,QAA6B,iCAA7B,CAAA;;IAOA;;;AAIC,aAJD,eAIC,GAAA;8BAJD,iBAIC;;2EAJD,6BAIC;;AAGC,cAAK,UAAL,GAAkB,IAAlB,CAHD;AAIC,cAAK,OAAL,GAAe,CAAf,CAJD;;KAAA;;iBAJD;;8BAsBO,OAAa;AAElB,iBAAK,eAAL,GAFkB;AAIlB,iBAAK,MAAL,GAJkB;AAKlB,iBAAK,OAAL,GAAe,CAAf,CALkB;AAMlB,gBAAG,EAAE,QAAM,CAAN,CAAF,EAAY,QAAQ,CAAR,CAAf;AACA,gBAAG,SAAS,KAAT,CAAH,EACC,KAAK,UAAL,GAAkB,WAAW,gBAAgB,QAAhB,EAA0B,KAArC,EAA4C,IAA5C,CAAlB,CADD;;;;2CAIe;AAEf,iBAAK,eAAL,GAFe;AAGf,4BAAgB,QAAhB,CAAyB,IAAzB,EAHe;;;;oCAMG;AAElB,mBAAO,KAAK,OAAL,CAFW;;;;qCA4BC;AAEnB,iBAAK,MAAL,GAFmB;AAGnB,iBAAK,OAAL,GAAe,IAAf,CAHmB;;;;iCAMd;AAEL,gBAAI,KAAK,KAAK,UAAL,CAFJ;AAGL,gBAAG,EAAH,EACA;AACC,6BAAa,EAAb,EADD;AAEC,qBAAK,UAAL,GAAkB,IAAlB,CAFD;AAGC,qBAAK,OAAL,GAAe,CAAf,CAHD;AAIC,uBAAO,IAAP,CAJD;aADA;AAOA,mBAAO,KAAP,CAVK;;;;4BA5DS;AAEd,mBAAO,CAAC,CAAC,KAAK,UAAL,CAFK;;;;4BA+BL;AAET,mBAAO,KAAK,SAAL,EAAP,CAFS;;;;iCAMc,GAAiB;AAExC,cAAE,MAAF,GAFwC;AAGxC,cAAE,OAAF,GAAY,CAAZ,CAHwC;AAIxC,gBACA;AACC,kBAAE,UAAF,GADD;AAEC,kBAAE,OAAF,GAAY,CAAZ,CAFD;aADA,CAKA,OAAM,EAAN,EACA;AACC,kBAAE,OAAF,GAAY,CAAZ,CADD;aADA;;;;WA3DF;EAA8C,iBAAA,cAAA;;AAAxB,QAAA,eAAA,GAAe,eAAf;AAyFtB,OAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA,EAAA,OAAA,IAAA,EAAA;ADvCA,QAAQ,OAAR,GCuCe,eDvCf","file":"System/Threading/Tasks/TaskHandlerBase.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst DisposableBase_1 = require(\"../../Disposable/DisposableBase\");\nclass TaskHandlerBase extends DisposableBase_1.DisposableBase {\n    constructor() {\n        super();\n        this._timeoutId = null;\n        this._status = 0;\n    }\n    get isScheduled() {\n        return !!this._timeoutId;\n    }\n    start(defer) {\n        this.throwIfDisposed();\n        this.cancel();\n        this._status = 1;\n        if (!(defer > 0))\n            defer = 0;\n        if (isFinite(defer))\n            this._timeoutId = setTimeout(TaskHandlerBase._handler, defer, this);\n    }\n    runSynchronously() {\n        this.throwIfDisposed();\n        TaskHandlerBase._handler(this);\n    }\n    getStatus() {\n        return this._status;\n    }\n    get status() {\n        return this.getStatus();\n    }\n    static _handler(d) {\n        d.cancel();\n        d._status = 2;\n        try {\n            d._onExecute();\n            d._status = 3;\n        }\n        catch (ex) {\n            d._status = 5;\n        }\n    }\n    _onDispose() {\n        this.cancel();\n        this._status = null;\n    }\n    cancel() {\n        var id = this._timeoutId;\n        if (id) {\n            clearTimeout(id);\n            this._timeoutId = null;\n            this._status = 4;\n            return true;\n        }\n        return false;\n    }\n}\nexports.TaskHandlerBase = TaskHandlerBase;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = TaskHandlerBase;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {DisposableBase} from \"../../Disposable/DisposableBase\";\r\nimport {ICancellable} from \"../ICancellable\";\r\nimport {TaskStatus} from \"./TaskStatus\";\r\n\r\n/**\r\n * A simple class for handling potentially repeated executions either deferred or immediate.\r\n */\r\nexport abstract class TaskHandlerBase extends DisposableBase implements ICancellable\r\n{\r\n\tprivate _status:TaskStatus;\r\n\r\n\tconstructor()\r\n\t{\r\n\t\tsuper();\r\n\t\tthis._timeoutId = null;\r\n\t\tthis._status = TaskStatus.Created\r\n\t}\r\n\r\n\tprivate _timeoutId:any;\r\n\r\n\tget isScheduled():boolean\r\n\t{\r\n\t\treturn !!this._timeoutId;\r\n\t}\r\n\r\n\t/**\r\n\t * Schedules/Reschedules triggering the task.\r\n\t * @param defer Optional time to wait until triggering.\r\n\t */\r\n\tstart(defer?:number):void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tthis.cancel();\r\n\t\tthis._status = TaskStatus.WaitingToRun;\r\n\t\tif(!(defer>0)) defer = 0;\r\n\t\tif(isFinite(defer))\r\n\t\t\tthis._timeoutId = setTimeout(TaskHandlerBase._handler, defer, this);\r\n\t}\r\n\r\n\trunSynchronously():void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tTaskHandlerBase._handler(this);\r\n\t}\r\n\r\n\tprotected getStatus():TaskStatus\r\n\t{\r\n\t\treturn this._status;\r\n\t}\r\n\r\n\tget status():TaskStatus\r\n\t{\r\n\t\treturn this.getStatus();\r\n\t}\r\n\r\n\t// Use a static function here to avoid recreating a new function every time.\r\n\tprivate static _handler(d:TaskHandlerBase):void\r\n\t{\r\n\t\td.cancel();\r\n\t\td._status = TaskStatus.Running;\r\n\t\ttry\r\n\t\t{\r\n\t\t\td._onExecute();\r\n\t\t\td._status = TaskStatus.RanToCompletion;\r\n\t\t}\r\n\t\tcatch(ex)\r\n\t\t{\r\n\t\t\td._status = TaskStatus.Faulted;\r\n\t\t}\r\n\t}\r\n\r\n\tprotected abstract _onExecute():void;\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tthis.cancel();\r\n\t\tthis._status = null;\r\n\t}\r\n\r\n\tcancel():boolean\r\n\t{\r\n\t\tvar id = this._timeoutId;\r\n\t\tif(id)\r\n\t\t{\r\n\t\t\tclearTimeout(id);\r\n\t\t\tthis._timeoutId = null;\r\n\t\t\tthis._status = TaskStatus.Cancelled;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n}\r\n\r\nexport default TaskHandlerBase;"]}