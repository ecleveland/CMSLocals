{"version":3,"sources":["System/Threading/Tasks/Task.js","System/Threading/Tasks/Task.ts"],"names":[],"mappings":";;;;AAIA;;;;;;;;;;;;ACCA,IAAA,oBAAA,QAA8B,mBAA9B,CAAA;AACA,IAAA,0BAAA,QAAoC,wCAApC,CAAA;AAEA,IAAA,SAAA,QAAmB,YAAnB,CAAA;;IAQA;;;AAIC,aAJD,IAIC,CAAY,YAAZ,EAAgC;8BAJjC,MAIiC;;2EAJjC,kBAIiC;;AAG/B,YAAG,CAAC,YAAD,EAAe,MAAM,IAAI,wBAAA,qBAAA,CAAsB,cAA1B,CAAN,CAAlB;AACA,cAAK,OAAL,GAAe,IAAI,OAAA,IAAA,CAAK,YAAT,EAAuB,KAAvB,CAAf,CAJ+B;;KAAhC;;iBAJD;;qCAWqB;AAEnB,iBAAK,OAAL,CAAa,QAAb,GAFmB;;;;oCAKD;AAElB,mBAAO,KAAK,OAAL,CAAa,KAAb,CAFW;;;;mCAKD;AAEjB,gBAAI,IAAI,KAAK,OAAL,CAFS;AAGjB,mBAAO,KAAK;AACV,wBAAQ,KAAK,SAAL,EAAR;AACA,wBAAQ,EAAE,cAAF,GAAmB,EAAE,KAAF,GAAU,KAAK,CAAL;AACrC,uBAAO,EAAE,KAAF;aAHF,CAHU;;;;8BAWZ,OAAa;AAElB,gBAAG,KAAK,SAAL,MAAkB,CAAlB,EACH;AACC,2CApCH,2CAoCe,MAAZ,CADD;aADA;;;;2CAMe;AAEf,gBAAG,KAAK,SAAL,MAAkB,CAAlB,EACH;AACC,2CA5CH,qDA4CG,CADD;aADA;;;;qCAwBmB;AAEnB,uCApEF,+CAoEE,CAFmB;AAGnB,gBAAI,IAAI,KAAK,OAAL,CAHW;AAKnB,gBAAG,CAAH,EACA;AACC,qBAAK,OAAL,GAAe,IAAf,CADD;AAEC,kBAAE,OAAF,GAFD;aADA;;;;4BAvBQ;AAER,mBAAO,KAAK,QAAL,EAAP,CAFQ;;;;4BAKC;AAET,iBAAK,eAAL,GAFS;AAGT,iBAAK,gBAAL,GAHS;AAIT,mBAAO,KAAK,SAAL,EAAP,CAJS;;;;4BAOD;AAER,iBAAK,eAAL,GAFQ;AAGR,mBAAO,KAAK,OAAL,CAAa,KAAb,CAHC;;;;WA5DV;EAA6B,kBAAA,eAAA;;AAAhB,QAAA,IAAA,GAAI,IAAJ;AA+Eb,OAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA,EAAA,OAAA,IAAA,EAAA;ADjCA,QAAQ,OAAR,GCiCe,IDjCf","file":"System/Threading/Tasks/Task.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst TaskHandlerBase_1 = require(\"./TaskHandlerBase\");\nconst ArgumentNullException_1 = require(\"../../Exceptions/ArgumentNullException\");\nconst Lazy_1 = require(\"../../Lazy\");\nclass Task extends TaskHandlerBase_1.TaskHandlerBase {\n    constructor(valueFactory) {\n        super();\n        if (!valueFactory)\n            throw new ArgumentNullException_1.ArgumentNullException('valueFactory');\n        this._result = new Lazy_1.Lazy(valueFactory, false);\n    }\n    _onExecute() {\n        this._result.getValue();\n    }\n    getResult() {\n        return this._result.value;\n    }\n    getState() {\n        var r = this._result;\n        return r && {\n            status: this.getStatus(),\n            result: r.isValueCreated ? r.value : void 0,\n            error: r.error\n        };\n    }\n    start(defer) {\n        if (this.getStatus() == 0) {\n            super.start(defer);\n        }\n    }\n    runSynchronously() {\n        if (this.getStatus() == 0) {\n            super.runSynchronously();\n        }\n    }\n    get state() {\n        return this.getState();\n    }\n    get result() {\n        this.throwIfDisposed();\n        this.runSynchronously();\n        return this.getResult();\n    }\n    get error() {\n        this.throwIfDisposed();\n        return this._result.error;\n    }\n    _onDispose() {\n        super._onDispose();\n        var r = this._result;\n        if (r) {\n            this._result = null;\n            r.dispose();\n        }\n    }\n}\nexports.Task = Task;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Task;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {TaskHandlerBase} from \"./TaskHandlerBase\";\r\nimport {ArgumentNullException} from \"../../Exceptions/ArgumentNullException\";\r\nimport {Func} from \"../../FunctionTypes\";\r\nimport {Lazy} from \"../../Lazy\";\r\nimport {ITaskState} from \"./ITaskState\";\r\nimport {TaskStatus} from \"./TaskStatus\";\r\n\r\n/**\r\n * A simplified synchronous (but deferrable) version of Task<T>\r\n * Asynchronous operations should use Promise<T>.\r\n */\r\nexport class Task<T> extends TaskHandlerBase\r\n{\r\n\tprivate _result:Lazy<T>;\r\n\r\n\tconstructor(valueFactory:Func<T>)\r\n\t{\r\n\t\tsuper();\r\n\t\tif(!valueFactory) throw new ArgumentNullException('valueFactory');\r\n\t\tthis._result = new Lazy(valueFactory, false);\r\n\t}\r\n\r\n\tprotected _onExecute():void\r\n\t{\r\n\t\tthis._result.getValue();\r\n\t}\r\n\r\n\tprotected getResult():T\r\n\t{\r\n\t\treturn this._result.value; // This will detect any potential recursion.\r\n\t}\r\n\r\n\tprotected getState():ITaskState<T>\r\n\t{\r\n\t\tvar r = this._result;\r\n\t\treturn r && {\r\n\t\t\t\tstatus: this.getStatus(),\r\n\t\t\t\tresult: r.isValueCreated ? r.value : void 0,\r\n\t\t\t\terror: r.error\r\n\t\t\t};\r\n\t}\r\n\r\n\r\n\tstart(defer?:number):void\r\n\t{\r\n\t\tif(this.getStatus()==TaskStatus.Created)\r\n\t\t{\r\n\t\t\tsuper.start(defer);\r\n\t\t}\r\n\t}\r\n\r\n\trunSynchronously():void\r\n\t{\r\n\t\tif(this.getStatus()==TaskStatus.Created)\r\n\t\t{\r\n\t\t\tsuper.runSynchronously();\r\n\t\t}\r\n\t}\r\n\r\n\tget state():ITaskState<T>\r\n\t{\r\n\t\treturn this.getState();\r\n\t}\r\n\r\n\tget result():T\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tthis.runSynchronously();\r\n\t\treturn this.getResult();\r\n\t}\r\n\r\n\tget error():any\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn this._result.error;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tvar r = this._result;\r\n\r\n\t\tif(r)\r\n\t\t{\r\n\t\t\tthis._result = null;\r\n\t\t\tr.dispose();\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport default Task;"]}