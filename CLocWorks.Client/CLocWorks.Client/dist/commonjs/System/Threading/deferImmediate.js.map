{"version":3,"sources":["System/Threading/deferImmediate.js","System/Threading/deferImmediate.ts"],"names":[],"mappings":"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","file":"System/Threading/deferImmediate.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n * Based on code from: https://github.com/kriskowal/q\n */\n\"use strict\";\nconst Types_1 = require(\"../Types\");\nconst LinkedNodeList_1 = require(\"../Collections/LinkedNodeList\");\nconst Queue_1 = require(\"../Collections/Queue\");\nconst ObjectPool_1 = require(\"../Disposable/ObjectPool\");\nvar requestTick;\nvar isNodeJS = false;\nvar flushing = false;\nfunction flush() {\n    var entry;\n    while (entry = immediateQueue.first) {\n        let { task, domain, context, args } = entry;\n        entry.canceller();\n        if (domain)\n            domain.enter();\n        runSingle(task, domain, context, args);\n    }\n    let task;\n    while (task = laterQueue.dequeue()) {\n        runSingle(task);\n    }\n    flushing = false;\n}\nvar immediateQueue = new LinkedNodeList_1.LinkedNodeList();\nvar laterQueue = new Queue_1.Queue();\nvar entryPool = new ObjectPool_1.ObjectPool(40, () => ({}), o => {\n    o.task = null;\n    o.domain = null;\n    o.context = null;\n    if (o.args)\n        o.args.length = 0;\n    o.args = null;\n    o.canceller = null;\n});\nfunction runSingle(task, domain, context, params) {\n    try {\n        task.apply(context, params);\n    }\n    catch (e) {\n        if (isNodeJS) {\n            if (domain) {\n                domain.exit();\n            }\n            setTimeout(flush, 0);\n            if (domain) {\n                domain.enter();\n            }\n            throw e;\n        }\n        else {\n            setTimeout(() => {\n                throw e;\n            }, 0);\n        }\n    }\n    if (domain) {\n        domain.exit();\n    }\n}\nfunction requestFlush() {\n    if (!flushing) {\n        flushing = true;\n        requestTick();\n    }\n}\nfunction deferImmediate(task, context, args) {\n    var entry = entryPool.take();\n    entry.task = task;\n    entry.domain = isNodeJS && process['domain'];\n    entry.context = context;\n    entry.args = args && args.slice();\n    entry.canceller = () => {\n        if (!entry)\n            return false;\n        let r = !!immediateQueue.removeNode(entry);\n        entryPool.add(entry);\n        entry = null;\n        return r;\n    };\n    immediateQueue.addNode(entry);\n    requestFlush();\n    return {\n        cancel: entry.canceller,\n        dispose: () => { entry && entry.canceller(); }\n    };\n}\nexports.deferImmediate = deferImmediate;\nfunction runAfterDeferred(task) {\n    laterQueue.enqueue(task);\n    requestFlush();\n}\nexports.runAfterDeferred = runAfterDeferred;\nif (Types_1.Type.isObject(process)\n    && process.toString() === \"[object process]\"\n    && process.nextTick) {\n    isNodeJS = true;\n    requestTick = () => {\n        process.nextTick(flush);\n    };\n}\nelse if (typeof setImmediate === \"function\") {\n    if (typeof window !== \"undefined\") {\n        requestTick = setImmediate.bind(window, flush);\n    }\n    else {\n        requestTick = () => {\n            setImmediate(flush);\n        };\n    }\n}\nelse if (typeof MessageChannel !== \"undefined\") {\n    var channel = new MessageChannel();\n    channel.port1.onmessage = function () {\n        requestTick = requestPortTick;\n        channel.port1.onmessage = flush;\n        flush();\n    };\n    var requestPortTick = () => {\n        channel.port2.postMessage(0);\n    };\n    requestTick = () => {\n        setTimeout(flush, 0);\n        requestPortTick();\n    };\n}\nelse {\n    requestTick = () => {\n        setTimeout(flush, 0);\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = deferImmediate;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Based on code from: https://github.com/kriskowal/q\r\n */\r\n\r\n\r\nimport {Type} from \"../Types\";\r\nimport {LinkedNodeList} from \"../Collections/LinkedNodeList\";\r\nimport {Queue} from \"../Collections/Queue\";\r\nimport {Closure} from \"../FunctionTypes\";\r\nimport {ILinkedNode} from \"../Collections/ILinkedListNode\";\r\nimport {ICancellable} from \"./ICancellable\";\r\nimport {ObjectPool} from \"../Disposable/ObjectPool\";\r\n\r\ndeclare module process\r\n{\r\n\texport function nextTick(callback:Closure):void;\r\n\r\n\texport function toString():string;\r\n}\r\n\r\ninterface IDomain\r\n{\r\n\tenter():void;\r\n\texit():void;\r\n}\r\n\r\ninterface ITaskQueueEntry extends ILinkedNode<ITaskQueueEntry>\r\n{\r\n\ttask:Function;\r\n\tdomain?:IDomain;\r\n\tcontext?:any;\r\n\targs?:any[];\r\n\tcanceller:()=>boolean;\r\n}\r\n\r\n\r\nvar requestTick:()=>void;\r\nvar isNodeJS:boolean = false;\r\nvar flushing:boolean = false;\r\n\r\n// Use the fastest possible means to execute a task in a future turn\r\n// of the event loop.\r\n\r\n\r\nfunction flush():void\r\n{\r\n\t/* jshint loopfunc: true */\r\n\tvar entry:ITaskQueueEntry;\r\n\twhile(entry = immediateQueue.first)\r\n\t{\r\n\t\tlet {task, domain, context, args} = entry;\r\n\t\tentry.canceller();\r\n\t\tif(domain) domain.enter();\r\n\t\trunSingle(task, domain, context, args);\r\n\t}\r\n\r\n\tlet task:Closure;\r\n\twhile(task = laterQueue.dequeue())\r\n\t{\r\n\t\trunSingle(task);\r\n\t}\r\n\r\n\tflushing = false;\r\n}\r\n\r\n\r\n// linked list of tasks.  Using a real linked list to allow for removal.\r\nvar immediateQueue = new LinkedNodeList<ITaskQueueEntry>();\r\n\r\n// queue for late tasks, used by unhandled rejection tracking\r\nvar laterQueue = new Queue<Closure>();\r\n\r\nvar entryPool = new ObjectPool<ITaskQueueEntry>(40,\r\n\t()=><any>{},\r\n\to=>\r\n\t{\r\n\t\to.task = null;\r\n\t\to.domain = null;\r\n\t\to.context = null;\r\n\t\tif(o.args) o.args.length = 0;\r\n\t\to.args = null;\r\n\t\to.canceller = null;\r\n\t});\r\n\r\nfunction runSingle(task:Function, domain?:IDomain, context?:any, params?:any[]):void\r\n{\r\n\ttry\r\n\t{\r\n\t\ttask.apply(context, params);\r\n\t}\r\n\tcatch(e)\r\n\t{\r\n\t\tif(isNodeJS)\r\n\t\t{\r\n\t\t\t// In node, uncaught exceptions are considered fatal errors.\r\n\t\t\t// Re-throw them synchronously to interrupt flushing!\r\n\r\n\t\t\t// Ensure continuation if the uncaught exception is suppressed\r\n\t\t\t// listening \"uncaughtException\" events (as domains does).\r\n\t\t\t// Continue in next event to avoid tick recursion.\r\n\t\t\tif(domain)\r\n\t\t\t{\r\n\t\t\t\tdomain.exit();\r\n\t\t\t}\r\n\t\t\tsetTimeout(flush, 0);\r\n\t\t\tif(domain)\r\n\t\t\t{\r\n\t\t\t\tdomain.enter();\r\n\t\t\t}\r\n\r\n\t\t\tthrow e;\r\n\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// In browsers, uncaught exceptions are not fatal.\r\n\t\t\t// Re-throw them asynchronously to avoid slow-downs.\r\n\t\t\tsetTimeout(()=>\r\n\t\t\t{\r\n\t\t\t\tthrow e;\r\n\t\t\t}, 0);\r\n\t\t}\r\n\t}\r\n\r\n\tif(domain)\r\n\t{\r\n\t\tdomain.exit();\r\n\t}\r\n}\r\n\r\nfunction requestFlush():void\r\n{\r\n\tif(!flushing)\r\n\t{\r\n\t\tflushing = true;\r\n\t\trequestTick();\r\n\t}\r\n}\r\n\r\nexport function deferImmediate(task:Closure, context?:any):ICancellable\r\n/**\r\n * @param task The function to call.\r\n * @param context The context (aka this) to call on. Null or undefined = global.\r\n * @param args The parameters to pass to the function.\r\n * @returns {{cancel: (function(): boolean), dispose: (function(): undefined)}}\r\n */\r\nexport function deferImmediate(task:Function, context?:any, args?:any[]):ICancellable\r\nexport function deferImmediate(task:Closure|Function, context?:any, args?:any[]):ICancellable\r\n{\r\n\tvar entry:ITaskQueueEntry = entryPool.take();\r\n\tentry.task = task;\r\n\tentry.domain = isNodeJS && (<any>process)['domain'];\r\n\tentry.context = context;\r\n\tentry.args = args && args.slice();\r\n\tentry.canceller = ()=>\r\n\t{\r\n\t\tif(!entry) return false;\r\n\t\tlet r = !!immediateQueue.removeNode(entry);\r\n\t\tentryPool.add(entry);\r\n\t\tentry = null;\r\n\t\treturn r;\r\n\t};\r\n\r\n\timmediateQueue.addNode(entry);\r\n\r\n\trequestFlush();\r\n\r\n\treturn {\r\n\t\tcancel: entry.canceller,\r\n\t\tdispose: ()=> { entry && entry.canceller(); }\r\n\t}\r\n}\r\n\r\n\r\n// runs a task after all other tasks have been run\r\n// this is useful for unhandled rejection tracking that needs to happen\r\n// after all `then`d tasks have been run.\r\nexport function runAfterDeferred(task:Closure):void\r\n{\r\n\tlaterQueue.enqueue(task);\r\n\trequestFlush();\r\n}\r\n\r\n\r\nif(Type.isObject(process)\r\n\t&& process.toString()===\"[object process]\"\r\n\t&& process.nextTick)\r\n{\r\n\t/*\r\n\tEnsure is in a real Node environment, with a `process.nextTick`.\r\n\tTo see through fake Node environments:\r\n\t* Mocha test runner - exposes a `process` global without a `nextTick`\r\n\t* Browserify - exposes a `process.nexTick` function that uses\r\n\t  `setTimeout`. In this case `setImmediate` is preferred because\r\n\t   it is faster. Browserify's `process.toString()` yields\r\n\t  \"[object Object]\", while in a real Node environment\r\n\t  `process.nextTick()` yields \"[object process]\".\r\n\t*/\r\n\tisNodeJS = true;\r\n\r\n\trequestTick = ()=>\r\n\t{\r\n\t\tprocess.nextTick(flush);\r\n\t};\r\n\r\n}\r\nelse if(typeof setImmediate===\"function\")\r\n{\r\n\t// In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\r\n\tif(typeof window!==\"undefined\")\r\n\t{\r\n\t\trequestTick = setImmediate.bind(window, flush);\r\n\t}\r\n\telse\r\n\t{\r\n\t\trequestTick = ()=>\r\n\t\t{\r\n\t\t\tsetImmediate(flush);\r\n\t\t};\r\n\t}\r\n\r\n}\r\nelse if(typeof MessageChannel!==\"undefined\")\r\n{\r\n\t// modern browsers\r\n\t// http://www.nonblocking.io/2011/06/windownexttick.html\r\n\tvar channel = new MessageChannel();\r\n\t// At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\r\n\t// working message ports the first time a page loads.\r\n\tchannel.port1.onmessage = function()\r\n\t{\r\n\t\trequestTick = requestPortTick;\r\n\t\tchannel.port1.onmessage = flush;\r\n\t\tflush();\r\n\t};\r\n\tvar requestPortTick = ()=>\r\n\t{\r\n\t\t// Opera requires us to provide a message payload, regardless of\r\n\t\t// whether we use it.\r\n\t\tchannel.port2.postMessage(0);\r\n\t};\r\n\trequestTick = ()=>\r\n\t{\r\n\t\tsetTimeout(flush, 0);\r\n\t\trequestPortTick();\r\n\t};\r\n\r\n}\r\nelse\r\n{\r\n\t// old browsers\r\n\trequestTick = ()=>\r\n\t{\r\n\t\tsetTimeout(flush, 0);\r\n\t};\r\n}\r\n\r\nexport default deferImmediate;"]}