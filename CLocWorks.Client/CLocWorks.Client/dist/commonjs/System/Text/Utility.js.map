{"version":3,"sources":["System/Text/Utility.js","System/Text/Utility.ts"],"names":[],"mappings":"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","file":"System/Text/Utility.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst Types_1 = require(\"../Types\");\nexports.EMPTY = '';\nconst SPACE = ' ';\nconst ZERO = '0';\nfunction getHashCode(source) {\n    var hash = 0 | 0;\n    if (source.length == 0)\n        return hash;\n    for (let i = 0, l = source.length; i < l; i++) {\n        let ch = source.charCodeAt(i);\n        hash = ((hash << 5) - hash) + ch;\n        hash |= 0;\n    }\n    return hash;\n}\nexports.getHashCode = getHashCode;\nfunction repeat(source, count) {\n    var result = exports.EMPTY;\n    if (!isNaN(count)) {\n        for (let i = 0; i < count; i++) {\n            result += source;\n        }\n    }\n    return result;\n}\nexports.repeat = repeat;\nfunction fromChars(chOrChars, count = 1) {\n    if (Array.isArray(chOrChars)) {\n        let result = exports.EMPTY;\n        for (let char of chOrChars) {\n            result += String.fromCharCode(char);\n        }\n        return result;\n    }\n    else {\n        return repeat(String.fromCharCode(chOrChars), count);\n    }\n}\nexports.fromChars = fromChars;\nfunction escapeRegExp(source) {\n    return source.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n}\nexports.escapeRegExp = escapeRegExp;\nfunction trim(source, chars, ignoreCase) {\n    if (chars === exports.EMPTY)\n        return source;\n    if (chars) {\n        var escaped = escapeRegExp(Array.isArray(chars) ? chars.join() : chars);\n        return source.replace(new RegExp('^[' + escaped + ']+|[' + escaped + ']+$', 'g' + (ignoreCase\n            ? 'i'\n            : '')), exports.EMPTY);\n    }\n    return source.replace(/^\\s+|\\s+$/g, exports.EMPTY);\n}\nexports.trim = trim;\nfunction format(source, ...args) {\n    return supplant(source, args);\n}\nexports.format = format;\nfunction supplant(source, params) {\n    var oIsArray = Array.isArray(params);\n    return source.replace(/\\{([^{}]*)\\}/g, (a, b) => {\n        var n = b;\n        if (oIsArray) {\n            let i = parseInt(b);\n            if (!isNaN(i))\n                n = i;\n        }\n        var r = params[n];\n        switch (typeof r) {\n            case Types_1.Type.STRING:\n            case Types_1.Type.NUMBER:\n            case Types_1.Type.BOOLEAN:\n                return r;\n            default:\n                return (r && Types_1.Type.hasMemberOfType(r, \"toString\", Types_1.Type.FUNCTION))\n                    ? r.toString()\n                    : a;\n        }\n    });\n}\nexports.supplant = supplant;\nfunction canMatch(source, match) {\n    if (!Types_1.Type.isString(source) || !match)\n        return false;\n    if (source === match)\n        return true;\n    if (match.length < source.length)\n        return null;\n}\nfunction startsWith(source, pattern) {\n    var m = canMatch(source, pattern);\n    return Types_1.Type.isBoolean(m) ? m : source.indexOf(pattern) == 0;\n}\nexports.startsWith = startsWith;\nfunction endsWith(source, pattern) {\n    var m = canMatch(source, pattern);\n    return Types_1.Type.isBoolean(m) ? m : source.lastIndexOf(pattern) == (source.length - pattern.length);\n}\nexports.endsWith = endsWith;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {Type} from \"../Types\";\r\n\r\nexport const EMPTY:string = '';\r\nconst SPACE = ' ';\r\nconst ZERO = '0';\r\n\r\n/**\r\n * Returns a numerical (integer) hash code of the string.  Can be used for identifying inequality of contents, but two different strings in rare cases will have the same hash code.\r\n * @param source\r\n * @returns {number}\r\n */\r\nexport function getHashCode(source:string):number\r\n{\r\n\tvar hash = 0 | 0;\r\n\tif(source.length==0) return hash;\r\n\tfor(let i = 0, l = source.length; i<l; i++)\r\n\t{\r\n\t\tlet ch = source.charCodeAt(i);\r\n\t\thash = ((hash<<5) - hash) + ch;\r\n\t\thash |= 0; // Convert to 32bit integer\r\n\t}\r\n\treturn hash;\r\n}\r\n\r\nexport function repeat(source:string, count:number):string\r\n{\r\n\tvar result = EMPTY;\r\n\tif(!isNaN(count))\r\n\t{\r\n\t\tfor(let i = 0; i<count; i++)\r\n\t\t{\r\n\t\t\tresult += source;\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nexport function fromChars(ch:number, count:number):string\r\nexport function fromChars(chars:number[]):string\r\nexport function fromChars(chOrChars:any, count:number = 1):string\r\n{\r\n\tif(Array.isArray(chOrChars))\r\n\t{\r\n\t\tlet result = EMPTY;\r\n\t\tfor(let char of chOrChars)\r\n\t\t{\r\n\t\t\tresult += String.fromCharCode(char);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\telse\r\n\t{\r\n\t\treturn repeat(String.fromCharCode(chOrChars), count);\r\n\t}\r\n}\r\n\r\n/**\r\n * Escapes a RegExp sequence.\r\n * @param source\r\n * @returns {string}\r\n */\r\nexport function escapeRegExp(source:string):string\r\n{\r\n\treturn source.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\r\n}\r\n\r\n/**\r\n * Can trim any character or set of characters from the ends of a string.\r\n * Uses a Regex escapement to replace them with empty.\r\n * @param source\r\n * @param chars A string or array of characters desired to be trimmed.\r\n * @param ignoreCase\r\n * @returns {string}\r\n */\r\nexport function trim(source:string, chars?:string|string[], ignoreCase?:boolean):string\r\n{\r\n\tif(chars===EMPTY) return source;\r\n\tif(chars)\r\n\t{\r\n\t\tvar escaped = escapeRegExp(Array.isArray(chars) ? chars.join() : <string>chars);\r\n\t\treturn source.replace(new RegExp('^[' + escaped + ']+|[' + escaped + ']+$', 'g' + (ignoreCase\r\n\t\t\t\t? 'i'\r\n\t\t\t\t: '')), EMPTY);\r\n\t}\r\n\r\n\treturn source.replace(/^\\s+|\\s+$/g, EMPTY);\r\n}\r\n\r\n/**\r\n * Takes any arg\r\n * @param source\r\n * @param args\r\n * @returns {string}\r\n */\r\nexport function format(source:string, ...args:any[])\r\n{\r\n\treturn supplant(source, args);\r\n}\r\n\r\n//\r\n\r\n/**\r\n * This takes a string and replaces '{string}' with the respected parameter.\r\n * Also allows for passing an array in order to use '{n}' notation.\r\n * Not limited to an array's indexes.  For example, {length} is allowed.\r\n * Based upon Crockford's supplant function.\r\n * @param source\r\n * @param params\r\n * @returns {string}\r\n */\r\nexport function supplant(source:string, params:{[key:string]:any}|any[]):string\r\n{\r\n\tvar oIsArray = Array.isArray(params);\r\n\treturn source.replace(/\\{([^{}]*)\\}/g,\r\n\t\t(a:string, b:string):any=>\r\n\t\t{\r\n\t\t\tvar n:any = b;\r\n\t\t\tif(oIsArray)\r\n\t\t\t{\r\n\t\t\t\tlet i = parseInt(b);\r\n\t\t\t\tif(!isNaN(i)) n = i;\r\n\t\t\t}\r\n\r\n\t\t\tvar r = (<any>params)[n];\r\n\t\t\tswitch(typeof r)\r\n\t\t\t{\r\n\t\t\t\tcase Type.STRING:\r\n\t\t\t\tcase Type.NUMBER:\r\n\t\t\t\tcase Type.BOOLEAN:\r\n\t\t\t\t\treturn r;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn (r && Type.hasMemberOfType(r, \"toString\", Type.FUNCTION))\r\n\t\t\t\t\t\t? r.toString()\r\n\t\t\t\t\t\t: a;\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n}\r\n\r\n\r\nfunction canMatch(source:string, match:string):boolean\r\n{\r\n\tif(!Type.isString(source) || !match) return false;\r\n\tif(source===match) return true;\r\n\tif(match.length<source.length) return null;\r\n}\r\n\r\n/**\r\n * Returns true if the pattern matches the beginning of the source.\r\n * @param source\r\n * @param pattern\r\n * @returns {boolean}\r\n */\r\nexport function startsWith(source:string, pattern:string):boolean\r\n{\r\n\tvar m = canMatch(source, pattern);\r\n\treturn Type.isBoolean(m) ? m : source.indexOf(pattern)==0;\r\n}\r\n\r\n/**\r\n * Returns true if the pattern matches the end of the source.\r\n * @param source\r\n * @param pattern\r\n * @returns {boolean}\r\n */\r\nexport function endsWith(source:string, pattern:string):boolean\r\n{\r\n\tvar m = canMatch(source, pattern);\r\n\treturn Type.isBoolean(m) ? m : source.lastIndexOf(pattern)==(source.length - pattern.length);\r\n}\r\n\r\n"]}