{"version":3,"sources":["System/Text/RegularExpressions.js","System/Text/RegularExpressions.ts"],"names":[],"mappings":"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","file":"System/Text/RegularExpressions.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Named groups based on: http://trentrichardson.com/2011/08/02/javascript-regexp-match-named-captures/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst EMPTY = \"\";\nconst UNDEFINED = \"undefined\";\nconst _I = 'i', _G = 'g', _M = 'm', _U = 'u', _W = 'w', _Y = 'y';\nvar RegexOptions;\n(function (RegexOptions) {\n    RegexOptions.IGNORE_CASE = _I;\n    RegexOptions.I = _I;\n    RegexOptions.GLOBAL = _G;\n    RegexOptions.G = _G;\n    RegexOptions.MULTI_LINE = _M;\n    RegexOptions.M = _M;\n    RegexOptions.UNICODE = _U;\n    RegexOptions.U = _U;\n    RegexOptions.STICKY = _Y;\n    RegexOptions.Y = _Y;\n    RegexOptions.IGNORE_PATTERN_WHITESPACE = _W;\n    RegexOptions.W = _W;\n})(RegexOptions = exports.RegexOptions || (exports.RegexOptions = {}));\nclass Regex {\n    constructor(pattern, options, ...extra) {\n        if (!pattern)\n            throw new Error(\"'pattern' cannot be null or empty.\");\n        var patternString, flags = (options && (Array.isArray(options) ? options : [options]).concat(extra) || extra)\n            .join(EMPTY).toLowerCase();\n        if (pattern instanceof RegExp) {\n            let p = pattern;\n            if (p.ignoreCase && flags.indexOf(_I) === -1)\n                flags += _I;\n            if (p.multiline && flags.indexOf(_M) === -1)\n                flags += _M;\n            patternString = p.source;\n        }\n        else {\n            patternString = pattern;\n        }\n        var ignoreWhiteSpace = flags.indexOf(_W) != -1;\n        flags = flags.replace(/[gw]/g, EMPTY);\n        var keys = [];\n        {\n            let k = patternString.match(/(?!\\(\\?<)(\\w+)(?=>)/g);\n            if (k) {\n                for (let i = 0, len = k.length; i < len; i++) {\n                    keys[i + 1] = k[i];\n                }\n                patternString = patternString.replace(/\\?<\\w+>/g, EMPTY);\n                this._keys = keys;\n            }\n            if (ignoreWhiteSpace)\n                patternString = patternString.replace(/\\s+/g, \"\\\\s*\");\n            this._re = new RegExp(patternString, flags);\n        }\n        Object.freeze(this);\n    }\n    match(input, startIndex = 0) {\n        var _ = this;\n        var r;\n        if (!input\n            || startIndex >= input.length\n            || !(r = this._re.exec(input.substring(startIndex))))\n            return Match.Empty;\n        if (!(startIndex > 0))\n            startIndex = 0;\n        var first = startIndex + r.index, loc = first, groups = [], groupMap = {};\n        for (let i = 0, len = r.length; i < len; ++i) {\n            let text = r[i];\n            let g = EmptyGroup;\n            if (text !== null || text !== void 0) {\n                g = new Group(text, loc);\n                g.freeze();\n            }\n            if (i && _._keys && i < _._keys.length)\n                groupMap[_._keys[i]] = g;\n            groups.push(g);\n            if (i !== 0)\n                loc += text.length;\n        }\n        var m = new Match(r[0], first, groups, groupMap);\n        m.freeze();\n        return m;\n    }\n    matches(input) {\n        var matches = [], m, p = 0, end = input && input.length || 0;\n        while (p < end && (m = this.match(input, p)) && m.success) {\n            matches.push(m);\n            p = m.index + m.length;\n        }\n        return Object.freeze(matches);\n    }\n    replace(input, r, count = Infinity) {\n        if (!input || r === null || r === void 0 || !(count > 0))\n            return input;\n        var result = [];\n        var p = 0, end = input.length, isEvaluator = typeof r == \"function\";\n        var m, i = 0;\n        while (i < count && p < end && (m = this.match(input, p)) && m.success) {\n            let { index, length } = m;\n            if (p !== index)\n                result.push(input.substring(p, index));\n            result.push(isEvaluator ? r(m, i++) : r);\n            p = index + length;\n        }\n        if (p < end)\n            result.push(input.substring(p));\n        return result.join(EMPTY);\n    }\n    isMatch(input) {\n        return this._re.test(input);\n    }\n    static isMatch(input, pattern, options) {\n        var r = new Regex(pattern, options);\n        return r.isMatch(input);\n    }\n    static replace(input, pattern, e, options) {\n        var r = new Regex(pattern, options);\n        return r.replace(input, e);\n    }\n}\nexports.Regex = Regex;\nclass Capture {\n    constructor(value = EMPTY, index = -1) {\n        this.value = value;\n        this.index = index;\n    }\n    get length() {\n        var v = this.value;\n        return v && v.length || 0;\n    }\n    freeze() {\n        Object.freeze(this);\n    }\n}\nexports.Capture = Capture;\nclass Group extends Capture {\n    constructor(value = EMPTY, index = -1) {\n        super(value, index);\n    }\n    get success() {\n        return this.index != -1;\n    }\n    static get Empty() {\n        return EmptyGroup;\n    }\n}\nexports.Group = Group;\nconst EmptyGroup = new Group();\nEmptyGroup.freeze();\nclass Match extends Group {\n    constructor(value = EMPTY, index = -1, groups = [], namedGroups = {}) {\n        super(value, index);\n        this.groups = groups;\n        this.namedGroups = namedGroups;\n    }\n    freeze() {\n        if (!this.groups)\n            throw new Error(\"'groups' cannot be null.\");\n        if (!this.namedGroups)\n            throw new Error(\"'groupMap' cannot be null.\");\n        Object.freeze(this.groups.slice());\n        Object.freeze(this.namedGroups);\n        super.freeze();\n    }\n    static get Empty() {\n        return EmptyMatch;\n    }\n}\nexports.Match = Match;\nconst EmptyMatch = new Match();\nEmptyMatch.freeze();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Regex;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Named groups based on: http://trentrichardson.com/2011/08/02/javascript-regexp-match-named-captures/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n// NOTE: Avoid real (types/interfaces only = ok) dependencies so this class can be used cleanly.\r\nimport {IMap} from \"../Collections/Dictionaries/IDictionary\";\r\nimport {Primitive} from \"../Primitive\";\r\nimport {Selector} from \"../FunctionTypes\";\r\n\r\nconst EMPTY:string = \"\";\r\nconst UNDEFINED:string = \"undefined\";\r\nconst _I = 'i', _G = 'g', _M = 'm', _U = 'u', _W = 'w', _Y = 'y';\r\n\r\n\r\n/**\r\n * https://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regexoptions%28v=vs.110%29.aspx\r\n */\r\nexport module RegexOptions\r\n{\r\n\t/**\r\n\t * Specifies case-insensitive matching. For more information, see the \"Case-Insensitive Matching \" section in the Regular Expression Options topic.\r\n\t */\r\n\texport const IGNORE_CASE:string = _I;\r\n\texport const I:string = _I;\r\n\r\n\t/**\r\n\t * Specifies global matching instead of single.\r\n\t */\r\n\texport const GLOBAL:string = _G;\r\n\texport const G:string = _G;\r\n\r\n\t/**\r\n\t * treat beginning and end characters (^ and $) as working over multiple lines (i.e., match the beginning or end of each line (delimited by \\n or \\r), not only the very beginning or end of the whole input string)\r\n\t */\r\n\texport const MULTI_LINE:string = _M;\r\n\texport const M:string = _M;\r\n\r\n\t/**\r\n\t * treat pattern as a sequence of unicode code points\r\n\t */\r\n\texport const UNICODE:string = _U;\r\n\texport const U:string = _U;\r\n\r\n\t/**\r\n\t * matches only from the index indicated by the lastIndex property of this regular expression in the target string (and does not attempt to match from any later indexes).\r\n\t */\r\n\texport const STICKY:string = _Y;\r\n\texport const Y:string = _Y;\r\n\r\n\t/**\r\n\t * Modifies the pattern to ignore standard whitespace characters.\r\n\t */\r\n\texport const IGNORE_PATTERN_WHITESPACE:string = _W;\r\n\texport const W:string = _W;\r\n\r\n\texport type Global = 'g';\r\n\texport type IgnoreCase = 'i';\r\n\texport type MultiLine = 'm';\r\n\texport type Unicode = 'u';\r\n\texport type Sticky = 'y';\r\n\texport type IgnorePatternWhitespace = \"w\";\r\n\r\n\texport type Literal = Global | IgnoreCase | MultiLine | Unicode | Sticky | IgnorePatternWhitespace;\r\n}\r\n\r\nexport interface MatchEvaluator extends Selector<Match,Primitive>\r\n{\r\n}\r\n\r\nexport class Regex\r\n{\r\n\tprivate _re:RegExp;\r\n\tprivate _keys:string[];\r\n\r\n\tconstructor(\r\n\t\tpattern:string|RegExp,\r\n\t\toptions?:RegexOptions.Literal|RegexOptions.Literal[],\r\n\t\t...extra:RegexOptions.Literal[])\r\n\t{\r\n\t\tif(!pattern) throw new Error(\"'pattern' cannot be null or empty.\");\r\n\r\n\t\tvar patternString:string,\r\n\t\t    flags:string\r\n\t\t\t    = (options && (Array.isArray(options) ? options : [options]).concat(extra) || extra)\r\n\t\t\t    .join(EMPTY).toLowerCase();\r\n\r\n\t\tif(pattern instanceof RegExp)\r\n\t\t{\r\n\t\t\tlet p = <RegExp>pattern;\r\n\t\t\tif(p.ignoreCase && flags.indexOf(_I)=== -1)\r\n\t\t\t\tflags += _I;\r\n\t\t\tif(p.multiline && flags.indexOf(_M)=== -1)\r\n\t\t\t\tflags += _M;\r\n\t\t\tpatternString = p.source;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tpatternString = pattern;\r\n\t\t}\r\n\t\tvar ignoreWhiteSpace = flags.indexOf(_W)!= -1;\r\n\r\n\t\t// For the majority of expected behavior, we need to eliminate global and whitespace ignore.\r\n\t\tflags = flags.replace(/[gw]/g, EMPTY);\r\n\r\n\t\t// find the keys inside the pattern, and place in mapping array {0:'key1', 1:'key2', ...}\r\n\t\tvar keys:string[] = [];\r\n\t\t{\r\n\t\t\tlet k = patternString.match(/(?!\\(\\?<)(\\w+)(?=>)/g);\r\n\t\t\tif(k)\r\n\t\t\t{\r\n\t\t\t\tfor(let i = 0, len = k.length; i<len; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tkeys[i + 1] = k[i];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// remove keys from regexp leaving standard regexp\r\n\t\t\t\tpatternString = patternString.replace(/\\?<\\w+>/g, EMPTY);\r\n\t\t\t\tthis._keys = keys;\r\n\t\t\t}\r\n\r\n\t\t\tif(ignoreWhiteSpace)\r\n\t\t\t\tpatternString = patternString.replace(/\\s+/g, \"\\\\s*\");\r\n\r\n\t\t\tthis._re = new RegExp(patternString, flags);\r\n\r\n\t\t}\r\n\r\n\t\tObject.freeze(this);\r\n\t}\r\n\r\n\tmatch(input:string, startIndex:number = 0):Match\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar r:RegExpExecArray;\r\n\t\tif(!input\r\n\t\t\t|| startIndex>=input.length\r\n\t\t\t|| !(r = this._re.exec(input.substring(startIndex))))\r\n\t\t\treturn Match.Empty;\r\n\r\n\t\tif(!(startIndex>0)) startIndex = 0;\r\n\r\n\t\tvar first                = startIndex + r.index,\r\n\t\t    loc                  = first,\r\n\t\t    groups:Group[]       = [],\r\n\t\t    groupMap:IMap<Group> = {};\r\n\r\n\t\tfor(let i = 0, len = r.length; i<len; ++i)\r\n\t\t{\r\n\t\t\tlet text = r[i];\r\n\t\t\tlet g = EmptyGroup;\r\n\t\t\tif(text!==null || text!==void 0) {\r\n\t\t\t\t// Empty string might mean \\b match or similar.\r\n\t\t\t\tg = new Group(text, loc);\r\n\t\t\t\tg.freeze();\r\n\t\t\t}\r\n\t\t\tif(i && _._keys && i<_._keys.length) groupMap[_._keys[i]] = g;\r\n\t\t\tgroups.push(g);\r\n\t\t\tif(i!==0) loc += text.length;\r\n\t\t}\r\n\r\n\t\tvar m = new Match(r[0], first, groups, groupMap);\r\n\t\tm.freeze();\r\n\t\treturn m;\r\n\t}\r\n\r\n\tmatches(input:string):Match[]\r\n\t{\r\n\t\tvar matches:Match[] = [], m:Match, p = 0, end = input && input.length || 0;\r\n\t\twhile(p<end && (m = this.match(input, p)) && m.success)\r\n\t\t{\r\n\t\t\tmatches.push(m);\r\n\t\t\tp = m.index + m.length;\r\n\t\t}\r\n\t\treturn Object.freeze(matches);\r\n\t}\r\n\r\n\treplace(\r\n\t\tinput:string,\r\n\t\treplacement:Primitive,\r\n\t\tcount?:number):string;\r\n\r\n\treplace(\r\n\t\tinput:string,\r\n\t\tevaluator:MatchEvaluator,\r\n\t\tcount?:number):string;\r\n\r\n\treplace(\r\n\t\tinput:string,\r\n\t\tr:any,\r\n\t\tcount:number = Infinity):string\r\n\t{\r\n\t\tif(!input || r===null || r=== void 0 || !(count>0)) return input;\r\n\t\tvar result:string[] = [];\r\n\t\tvar p = 0, end = input.length, isEvaluator = typeof r==\"function\";\r\n\r\n\t\tvar m:Match, i:number = 0;\r\n\t\twhile(i<count && p<end && (m = this.match(input, p)) && m.success)\r\n\t\t{\r\n\t\t\tlet {index, length} = m;\r\n\t\t\tif(p!==index) result.push(input.substring(p, index));\r\n\t\t\tresult.push(isEvaluator ? r(m, i++) : r);\r\n\t\t\tp = index + length;\r\n\t\t}\r\n\r\n\t\tif(p<end) result.push(input.substring(p));\r\n\r\n\t\treturn result.join(EMPTY);\r\n\t}\r\n\r\n\tisMatch(input:string):boolean\r\n\t{\r\n\t\treturn this._re.test(input);\r\n\t}\r\n\r\n\tstatic isMatch(\r\n\t\tinput:string,\r\n\t\tpattern:string,\r\n\t\toptions?:RegexOptions.Literal[]):boolean\r\n\t{\r\n\t\tvar r = new Regex(pattern, options);\r\n\t\treturn r.isMatch(input);\r\n\t}\r\n\r\n\tstatic replace(\r\n\t\tinput:string,\r\n\t\tpattern:string,\r\n\t\treplacement:string,\r\n\t\toptions?:RegexOptions.Literal[]):string;\r\n\r\n\tstatic replace(\r\n\t\tinput:string,\r\n\t\tpattern:string,\r\n\t\tevaluator:MatchEvaluator,\r\n\t\toptions?:RegexOptions.Literal[]):string;\r\n\r\n\tstatic replace(\r\n\t\tinput:string,\r\n\t\tpattern:string,\r\n\t\te:any,\r\n\t\toptions?:RegexOptions.Literal[]):string\r\n\t{\r\n\t\tvar r = new Regex(pattern, options);\r\n\t\treturn r.replace(input, e);\r\n\t}\r\n}\r\n\r\nexport class Capture\r\n{\r\n\r\n\tget length():number\r\n\t{\r\n\t\tvar v = this.value;\r\n\t\treturn v && v.length || 0;\r\n\t}\r\n\r\n\tconstructor(\r\n\t\tpublic value:string = EMPTY,\r\n\t\tpublic index:number = -1)\r\n\t{\r\n\t}\r\n\r\n\tfreeze():void\r\n\t{\r\n\t\tObject.freeze(this);\r\n\t}\r\n}\r\n\r\nexport class Group extends Capture\r\n{\r\n\tget success():boolean\r\n\t{\r\n\t\treturn this.index!= -1;\r\n\t}\r\n\r\n\tconstructor(\r\n\t\tvalue:string = EMPTY,\r\n\t\tindex:number = -1)\r\n\t{\r\n\t\tsuper(value, index);\r\n\t}\r\n\r\n\tstatic get Empty():Group\r\n\t{\r\n\t\treturn EmptyGroup;\r\n\t}\r\n\r\n}\r\nconst EmptyGroup = new Group();\r\nEmptyGroup.freeze();\r\n\r\nexport class Match extends Group\r\n{\r\n\r\n\tconstructor(\r\n\t\tvalue:string = EMPTY,\r\n\t\tindex:number = -1,\r\n\t\tpublic groups:Group[] = [],\r\n\t\tpublic namedGroups:IMap<Group> = {})\r\n\t{\r\n\t\tsuper(value, index);\r\n\t}\r\n\r\n\tfreeze():void\r\n\t{\r\n\t\tif(!this.groups) throw new Error(\"'groups' cannot be null.\");\r\n\t\tif(!this.namedGroups) throw new Error(\"'groupMap' cannot be null.\");\r\n\t\tObject.freeze(this.groups.slice());\r\n\t\tObject.freeze(this.namedGroups);\r\n\t\tsuper.freeze();\r\n\t}\r\n\r\n\tstatic get Empty():Match\r\n\t{\r\n\t\treturn EmptyMatch;\r\n\t}\r\n}\r\nconst EmptyMatch = new Match();\r\nEmptyMatch.freeze();\r\n\r\n\r\nexport default Regex;"]}