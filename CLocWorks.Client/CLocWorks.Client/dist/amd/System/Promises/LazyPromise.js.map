{"version":3,"sources":["System/Promises/LazyPromise.js","System/Promises/LazyPromise.ts"],"names":["__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","define","require","exports","Promise_1","defer_1","ArgumentNullException_1","VOID0","LazyPromise","_super","_resolver","call","ArgumentNullException","_resolvedCalled","_onDispose","_onThen","r","resolveUsing","thenSynchronous","onFulfilled","onRejected","thenThis","delayFromNow","milliseconds","_this","throwIfDisposed","isSettled","pass","timedOut","timeout","defer","resolve","reject","v","e","dispose","delayAfterResolve","finalize","detector","isPending","Promise","defineProperty","value"],"mappings":"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","file":"System/Promises/LazyPromise.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT\n */\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\ndefine([\"require\", \"exports\", \"./Promise\", \"../Threading/defer\", \"../Exceptions/ArgumentNullException\"], function (require, exports, Promise_1, defer_1, ArgumentNullException_1) {\n    \"use strict\";\n    var VOID0 = void 0;\n    var LazyPromise = (function (_super) {\n        __extends(LazyPromise, _super);\n        function LazyPromise(_resolver) {\n            _super.call(this);\n            this._resolver = _resolver;\n            if (!_resolver)\n                throw new ArgumentNullException_1.ArgumentNullException(\"resolver\");\n            this._resolvedCalled = true;\n        }\n        LazyPromise.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._resolver = VOID0;\n        };\n        LazyPromise.prototype._onThen = function () {\n            var r = this._resolver;\n            if (r) {\n                this._resolver = VOID0;\n                this._resolvedCalled = false;\n                this.resolveUsing(r);\n            }\n        };\n        LazyPromise.prototype.thenSynchronous = function (onFulfilled, onRejected) {\n            this._onThen();\n            return _super.prototype.thenSynchronous.call(this, onFulfilled, onRejected);\n        };\n        LazyPromise.prototype.thenThis = function (onFulfilled, onRejected) {\n            this._onThen();\n            return _super.prototype.thenThis.call(this, onFulfilled, onRejected);\n        };\n        LazyPromise.prototype.delayFromNow = function (milliseconds) {\n            var _this = this;\n            if (milliseconds === void 0) { milliseconds = 0; }\n            this.throwIfDisposed();\n            if (!this._resolver || this.isSettled)\n                return _super.prototype.delayFromNow.call(this, milliseconds);\n            var pass;\n            var timedOut = false;\n            var timeout = defer_1.defer(function () {\n                timedOut = true;\n                if (pass)\n                    pass();\n            }, milliseconds);\n            return new LazyPromise(function (resolve, reject) {\n                pass = function () {\n                    _this.thenThis(function (v) { return resolve(v); }, function (e) { return reject(e); });\n                    timeout.dispose();\n                    timeout = null;\n                    pass = null;\n                };\n                if (timedOut)\n                    pass();\n            });\n        };\n        LazyPromise.prototype.delayAfterResolve = function (milliseconds) {\n            var _this = this;\n            if (milliseconds === void 0) { milliseconds = 0; }\n            this.throwIfDisposed();\n            if (!this._resolver || this.isSettled)\n                return _super.prototype.delayAfterResolve.call(this, milliseconds);\n            var pass;\n            var timeout;\n            var finalize = function () {\n                if (timeout) {\n                    timeout.dispose();\n                    timeout = null;\n                }\n                if (pass)\n                    pass();\n                finalize = null;\n            };\n            {\n                var detector = function () {\n                    if (finalize)\n                        timeout = defer_1.defer(finalize, milliseconds);\n                };\n                _super.prototype.thenThis.call(this, detector, detector);\n                detector = null;\n            }\n            return new LazyPromise(function (resolve, reject) {\n                if (_this.isPending) {\n                    _this.thenThis(function (v) { return defer_1.defer(function () { return resolve(v); }, milliseconds); }, function (e) { return defer_1.defer(function () { return reject(e); }, milliseconds); });\n                    finalize();\n                }\n                else {\n                    pass = function () {\n                        _this.thenThis(function (v) { return resolve(v); }, function (e) { return reject(e); });\n                    };\n                    if (!finalize)\n                        pass();\n                }\n            });\n        };\n        return LazyPromise;\n    }(Promise_1.Promise));\n    exports.LazyPromise = LazyPromise;\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = LazyPromise;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT\r\n */\r\n\r\nimport {Promise, PromiseBase} from \"./Promise\";\r\nimport {Closure} from \"../FunctionTypes\";\r\nimport {ICancellable} from \"../Threading/ICancellable\";\r\nimport {defer} from \"../Threading/defer\";\r\nimport {ArgumentNullException} from \"../Exceptions/ArgumentNullException\";\r\n\r\nconst VOID0:any = void 0;\r\n\r\n/**\r\n * A promise that waits for the first then to trigger the resolver.\r\n */\r\nexport class LazyPromise<T> extends Promise<T>\r\n{\r\n\r\n\tconstructor(private _resolver:Promise.Executor<T>)\r\n\t{\r\n\t\tsuper();\r\n\t\tif(!_resolver) throw new ArgumentNullException(\"resolver\");\r\n\t\tthis._resolvedCalled = true;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._resolver = VOID0;\r\n\t}\r\n\r\n\tprivate _onThen():void\r\n\t{\r\n\t\tvar r = this._resolver;\r\n\t\tif(r)\r\n\t\t{\r\n\t\t\tthis._resolver = VOID0;\r\n\t\t\tthis._resolvedCalled = false;\r\n\t\t\tthis.resolveUsing(r);\r\n\t\t}\r\n\t}\r\n\r\n\tthenSynchronous<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T, TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis._onThen();\r\n\t\treturn super.thenSynchronous(onFulfilled, onRejected);\r\n\t}\r\n\r\n\r\n\tthenThis(\r\n\t\tonFulfilled:(v?:T)=>any,\r\n\t\tonRejected?:(v?:any)=>any):PromiseBase<T>\r\n\t{\r\n\t\tthis._onThen();\r\n\t\treturn super.thenThis(onFulfilled, onRejected);\r\n\t}\r\n\r\n\t// NOTE: For a LazyPromise we need to be careful not to trigger the resolve for delay.\r\n\r\n\t/**\r\n\t * Will yield for a number of milliseconds from the time called before continuing.\r\n\t * @param milliseconds\r\n\t * @returns A promise that yields to the current execution and executes after a minimum delay.\r\n\t */\r\n\tdelayFromNow(milliseconds:number = 0):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\t// If this is already guaranteed to resolve, the go ahead and pass to the super.\r\n\t\tif(!this._resolver || this.isSettled)\r\n\t\t\treturn super.delayFromNow(milliseconds);\r\n\r\n\t\t/*\r\n\t\t * If not triggered yet, then we create a special promise\r\n\t\t * that only requests the resolution from the parent promise\r\n\t\t * if a 'then' is called to ensure the lazy pattern.\r\n\t\t */\r\n\t\tvar pass:Closure;\r\n\t\tvar timedOut:boolean = false;\r\n\r\n\t\t// Setup the timer.\r\n\t\tvar timeout = defer(()=>\r\n\t\t\t{\r\n\t\t\t\ttimedOut = true;\r\n\t\t\t\t// If the promise was requested already go ahead and pass the request on to the parent.\r\n\t\t\t\tif(pass)\r\n\t\t\t\t\tpass();\r\n\t\t\t},\r\n\t\t\tmilliseconds);\r\n\r\n\t\treturn new LazyPromise<T>(\r\n\t\t\t(resolve, reject)=>\r\n\t\t\t{\r\n\t\t\t\t// A lazy promise only enters here if something called for a resolution.\r\n\t\t\t\tpass = ()=>\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.thenThis(\r\n\t\t\t\t\t\tv=> resolve(v),\r\n\t\t\t\t\t\te=> reject(e)\r\n\t\t\t\t\t);\r\n\t\t\t\t\ttimeout.dispose();\r\n\t\t\t\t\ttimeout = null;\r\n\t\t\t\t\tpass = null;\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// If the timeout completed already go ahead and pass the request on to the parent.\r\n\t\t\t\tif(timedOut)\r\n\t\t\t\t\tpass();\r\n\t\t\t\t// Otherwise wait for the timeout to do it.\r\n\t\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Will yield for a number of milliseconds from after this promise resolves.\r\n\t * If the promise is already resolved, the delay will start from now.\r\n\t * @param milliseconds\r\n\t * @returns A promise that yields to the current execution and executes after a delay.\r\n\t */\r\n\tdelayAfterResolve(milliseconds:number = 0):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\t// If this is already guaranteed to resolve, the go ahead and pass to the super.\r\n\t\tif(!this._resolver || this.isSettled)\r\n\t\t\treturn super.delayAfterResolve(milliseconds);\r\n\r\n\t\t/*\r\n\t\t * If not triggered yet, then we create a special promise\r\n\t\t * that only requests the resolution from the parent promise\r\n\t\t * if a 'then' is called to ensure the lazy pattern.\r\n\t\t */\r\n\t\tvar pass:Closure;\r\n\r\n\r\n\t\t// Setup the timer.\r\n\t\tvar timeout:ICancellable;\r\n\r\n\t\tvar finalize = ()=>\r\n\t\t{\r\n\t\t\tif(timeout)\r\n\t\t\t{\r\n\t\t\t\ttimeout.dispose();\r\n\t\t\t\ttimeout = null;\r\n\t\t\t}\r\n\t\t\t// If the promise was requested already go ahead and pass the request on to the parent.\r\n\t\t\tif(pass)\r\n\t\t\t\tpass();\r\n\r\n\t\t\tfinalize = null;\r\n\t\t};\r\n\r\n\t\t{\r\n\t\t\tlet detector = ()=>\r\n\t\t\t{\r\n\t\t\t\tif(finalize) // We may already be wrapped up so never mind!\r\n\t\t\t\t\ttimeout = defer(finalize, milliseconds);\r\n\t\t\t};\r\n\r\n\t\t\t// Calling super.thenThis does not trigger resolution.\r\n\t\t\t// This simply waits for resolution to happen.\r\n\t\t\t// Is effectively the timer by when resolution has occurred.\r\n\t\t\tsuper.thenThis(detector, detector);\r\n\t\t\tdetector = null;\r\n\t\t}\r\n\r\n\t\treturn new LazyPromise<T>(\r\n\t\t\t(resolve, reject)=>\r\n\t\t\t{\r\n\t\t\t\t// Because of the lazy nature of this promise, this could enter here at any time.\r\n\t\t\t\tif(this.isPending)\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.thenThis(\r\n\t\t\t\t\t\tv=> defer(()=>resolve(v), milliseconds),\r\n\t\t\t\t\t\te=> defer(()=>reject(e), milliseconds)\r\n\t\t\t\t\t);\r\n\t\t\t\t\tfinalize();\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// We don't know when this resolved and could have happened anytime after calling this delay method.\r\n\t\t\t\t\tpass = ()=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis.thenThis(\r\n\t\t\t\t\t\t\tv=> resolve(v),\r\n\t\t\t\t\t\t\te=> reject(e)\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Already finalized (aka resolved after a timeout)? Go now!\r\n\t\t\t\t\tif(!finalize)\r\n\t\t\t\t\t\tpass();\r\n\t\t\t\t}\r\n\r\n\t\t\t});\r\n\r\n\t}\r\n}\r\n\r\nexport default LazyPromise;"]}