{"version":3,"sources":["System/Text/Utility.js","System/Text/Utility.ts"],"names":["define","require","exports","Types_1","getHashCode","source","hash","length","i","l","ch","charCodeAt","repeat","count","result","EMPTY","isNaN","fromChars","chOrChars","Array","isArray","_i","chOrChars_1","char","String","fromCharCode","escapeRegExp","replace","trim","chars","ignoreCase","escaped","join","RegExp","format","args","arguments","supplant","params","oIsArray","a","b","n","parseInt","r","Type","STRING","NUMBER","BOOLEAN","hasMemberOfType","FUNCTION","toString","canMatch","match","isString","startsWith","pattern","m","isBoolean","indexOf","endsWith","lastIndexOf"],"mappings":"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","file":"System/Text/Utility.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\ndefine([\"require\", \"exports\", \"../Types\"], function (require, exports, Types_1) {\n    \"use strict\";\n    exports.EMPTY = '';\n    var SPACE = ' ';\n    var ZERO = '0';\n    function getHashCode(source) {\n        var hash = 0 | 0;\n        if (source.length == 0)\n            return hash;\n        for (var i = 0, l = source.length; i < l; i++) {\n            var ch = source.charCodeAt(i);\n            hash = ((hash << 5) - hash) + ch;\n            hash |= 0;\n        }\n        return hash;\n    }\n    exports.getHashCode = getHashCode;\n    function repeat(source, count) {\n        var result = exports.EMPTY;\n        if (!isNaN(count)) {\n            for (var i = 0; i < count; i++) {\n                result += source;\n            }\n        }\n        return result;\n    }\n    exports.repeat = repeat;\n    function fromChars(chOrChars, count) {\n        if (count === void 0) { count = 1; }\n        if (Array.isArray(chOrChars)) {\n            var result = exports.EMPTY;\n            for (var _i = 0, chOrChars_1 = chOrChars; _i < chOrChars_1.length; _i++) {\n                var char = chOrChars_1[_i];\n                result += String.fromCharCode(char);\n            }\n            return result;\n        }\n        else {\n            return repeat(String.fromCharCode(chOrChars), count);\n        }\n    }\n    exports.fromChars = fromChars;\n    function escapeRegExp(source) {\n        return source.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n    }\n    exports.escapeRegExp = escapeRegExp;\n    function trim(source, chars, ignoreCase) {\n        if (chars === exports.EMPTY)\n            return source;\n        if (chars) {\n            var escaped = escapeRegExp(Array.isArray(chars) ? chars.join() : chars);\n            return source.replace(new RegExp('^[' + escaped + ']+|[' + escaped + ']+$', 'g' + (ignoreCase\n                ? 'i'\n                : '')), exports.EMPTY);\n        }\n        return source.replace(/^\\s+|\\s+$/g, exports.EMPTY);\n    }\n    exports.trim = trim;\n    function format(source) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        return supplant(source, args);\n    }\n    exports.format = format;\n    function supplant(source, params) {\n        var oIsArray = Array.isArray(params);\n        return source.replace(/\\{([^{}]*)\\}/g, function (a, b) {\n            var n = b;\n            if (oIsArray) {\n                var i = parseInt(b);\n                if (!isNaN(i))\n                    n = i;\n            }\n            var r = params[n];\n            switch (typeof r) {\n                case Types_1.Type.STRING:\n                case Types_1.Type.NUMBER:\n                case Types_1.Type.BOOLEAN:\n                    return r;\n                default:\n                    return (r && Types_1.Type.hasMemberOfType(r, \"toString\", Types_1.Type.FUNCTION))\n                        ? r.toString()\n                        : a;\n            }\n        });\n    }\n    exports.supplant = supplant;\n    function canMatch(source, match) {\n        if (!Types_1.Type.isString(source) || !match)\n            return false;\n        if (source === match)\n            return true;\n        if (match.length < source.length)\n            return null;\n    }\n    function startsWith(source, pattern) {\n        var m = canMatch(source, pattern);\n        return Types_1.Type.isBoolean(m) ? m : source.indexOf(pattern) == 0;\n    }\n    exports.startsWith = startsWith;\n    function endsWith(source, pattern) {\n        var m = canMatch(source, pattern);\n        return Types_1.Type.isBoolean(m) ? m : source.lastIndexOf(pattern) == (source.length - pattern.length);\n    }\n    exports.endsWith = endsWith;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {Type} from \"../Types\";\r\n\r\nexport const EMPTY:string = '';\r\nconst SPACE = ' ';\r\nconst ZERO = '0';\r\n\r\n/**\r\n * Returns a numerical (integer) hash code of the string.  Can be used for identifying inequality of contents, but two different strings in rare cases will have the same hash code.\r\n * @param source\r\n * @returns {number}\r\n */\r\nexport function getHashCode(source:string):number\r\n{\r\n\tvar hash = 0 | 0;\r\n\tif(source.length==0) return hash;\r\n\tfor(let i = 0, l = source.length; i<l; i++)\r\n\t{\r\n\t\tlet ch = source.charCodeAt(i);\r\n\t\thash = ((hash<<5) - hash) + ch;\r\n\t\thash |= 0; // Convert to 32bit integer\r\n\t}\r\n\treturn hash;\r\n}\r\n\r\nexport function repeat(source:string, count:number):string\r\n{\r\n\tvar result = EMPTY;\r\n\tif(!isNaN(count))\r\n\t{\r\n\t\tfor(let i = 0; i<count; i++)\r\n\t\t{\r\n\t\t\tresult += source;\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nexport function fromChars(ch:number, count:number):string\r\nexport function fromChars(chars:number[]):string\r\nexport function fromChars(chOrChars:any, count:number = 1):string\r\n{\r\n\tif(Array.isArray(chOrChars))\r\n\t{\r\n\t\tlet result = EMPTY;\r\n\t\tfor(let char of chOrChars)\r\n\t\t{\r\n\t\t\tresult += String.fromCharCode(char);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\telse\r\n\t{\r\n\t\treturn repeat(String.fromCharCode(chOrChars), count);\r\n\t}\r\n}\r\n\r\n/**\r\n * Escapes a RegExp sequence.\r\n * @param source\r\n * @returns {string}\r\n */\r\nexport function escapeRegExp(source:string):string\r\n{\r\n\treturn source.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\r\n}\r\n\r\n/**\r\n * Can trim any character or set of characters from the ends of a string.\r\n * Uses a Regex escapement to replace them with empty.\r\n * @param source\r\n * @param chars A string or array of characters desired to be trimmed.\r\n * @param ignoreCase\r\n * @returns {string}\r\n */\r\nexport function trim(source:string, chars?:string|string[], ignoreCase?:boolean):string\r\n{\r\n\tif(chars===EMPTY) return source;\r\n\tif(chars)\r\n\t{\r\n\t\tvar escaped = escapeRegExp(Array.isArray(chars) ? chars.join() : <string>chars);\r\n\t\treturn source.replace(new RegExp('^[' + escaped + ']+|[' + escaped + ']+$', 'g' + (ignoreCase\r\n\t\t\t\t? 'i'\r\n\t\t\t\t: '')), EMPTY);\r\n\t}\r\n\r\n\treturn source.replace(/^\\s+|\\s+$/g, EMPTY);\r\n}\r\n\r\n/**\r\n * Takes any arg\r\n * @param source\r\n * @param args\r\n * @returns {string}\r\n */\r\nexport function format(source:string, ...args:any[])\r\n{\r\n\treturn supplant(source, args);\r\n}\r\n\r\n//\r\n\r\n/**\r\n * This takes a string and replaces '{string}' with the respected parameter.\r\n * Also allows for passing an array in order to use '{n}' notation.\r\n * Not limited to an array's indexes.  For example, {length} is allowed.\r\n * Based upon Crockford's supplant function.\r\n * @param source\r\n * @param params\r\n * @returns {string}\r\n */\r\nexport function supplant(source:string, params:{[key:string]:any}|any[]):string\r\n{\r\n\tvar oIsArray = Array.isArray(params);\r\n\treturn source.replace(/\\{([^{}]*)\\}/g,\r\n\t\t(a:string, b:string):any=>\r\n\t\t{\r\n\t\t\tvar n:any = b;\r\n\t\t\tif(oIsArray)\r\n\t\t\t{\r\n\t\t\t\tlet i = parseInt(b);\r\n\t\t\t\tif(!isNaN(i)) n = i;\r\n\t\t\t}\r\n\r\n\t\t\tvar r = (<any>params)[n];\r\n\t\t\tswitch(typeof r)\r\n\t\t\t{\r\n\t\t\t\tcase Type.STRING:\r\n\t\t\t\tcase Type.NUMBER:\r\n\t\t\t\tcase Type.BOOLEAN:\r\n\t\t\t\t\treturn r;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn (r && Type.hasMemberOfType(r, \"toString\", Type.FUNCTION))\r\n\t\t\t\t\t\t? r.toString()\r\n\t\t\t\t\t\t: a;\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n}\r\n\r\n\r\nfunction canMatch(source:string, match:string):boolean\r\n{\r\n\tif(!Type.isString(source) || !match) return false;\r\n\tif(source===match) return true;\r\n\tif(match.length<source.length) return null;\r\n}\r\n\r\n/**\r\n * Returns true if the pattern matches the beginning of the source.\r\n * @param source\r\n * @param pattern\r\n * @returns {boolean}\r\n */\r\nexport function startsWith(source:string, pattern:string):boolean\r\n{\r\n\tvar m = canMatch(source, pattern);\r\n\treturn Type.isBoolean(m) ? m : source.indexOf(pattern)==0;\r\n}\r\n\r\n/**\r\n * Returns true if the pattern matches the end of the source.\r\n * @param source\r\n * @param pattern\r\n * @returns {boolean}\r\n */\r\nexport function endsWith(source:string, pattern:string):boolean\r\n{\r\n\tvar m = canMatch(source, pattern);\r\n\treturn Type.isBoolean(m) ? m : source.lastIndexOf(pattern)==(source.length - pattern.length);\r\n}\r\n\r\n"]}